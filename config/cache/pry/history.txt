Type.all
quit
Typa.all
Type.all
quit
Type.all
Type.pluck(:name)
quit
ary = [1,2,3,4,5]
ary.pop(1)
ary
exit
ary.pop(1)
exit
ary = [1,2,3,4,5]
ary.push(1)
exit
cd Array
ls
cd
help
show-doc Array
show-doc Class:Array
show-doc Class Array
show-doc Array
cd Array
show-doc Array
ri -help
ri Array#each
exit
quit
? Array
$ Array
show-doc Array
help
show-source Array
show-doc select
pry-doc
show-doc select
select
show-doc Hash
quit
exit
show-source Object
show-doc Object
show-source Array -d
show-source Array
show-source Hash -d
show-source #reject
show-source reject
$ reject
? reject
? Reject
show-doc Array#sort!
show-doc Array#pop
!!!
show-doc Array#pop
show-source Array#pop
show-source Array#pop -d
show-source Array pop -d
show-source pop -d
cd Array
ls
show-source pop -d
? pop
$ pop
exit
quit
Type.all
quit
Type.all
quit
Type.all
:Q
quit
Type.all
quit
Type.all
quit
file = "types.json"
data_hash = JSON.parse(File.read(file))
require 'pry'                                                                  ▏data_hash = JSON.parse(File.read(file))
  >----------Bookmarks---------▏    6 require 'json'
require 'json'
file = "types.json"
data_hash = JSON.parse(File.read(file))
quit
require 'json'
file = "types.json"
data_hash = JSON.parse(File.read(file))
quit
result
data_hash
Type.all
quit
Type.all
quit
time_stamps(1)
time = 336
336 / 60
336.to_f / 60
time = 787
time.to_f / 60
quit
aa = {
    {
        "name": "comfort",
        "methods": ["act focused", "planned", "organized"],
        "metadata": ["women also included in the group"],
        "motivation": ["power", "dominance"],
        "gain": ["material", "money"],
        "victims": ["known"],
        "geographical": ["concentrated"],
        "crime_scene_traits": ["controlled crime scene", "specific victim", "weapon at scene", "relational victim", "victim known"]
    },
     {
        "name": "lust",
        "methods": ["process-focused", "planned", "organized"],
        "metadata": [""],
        "motivation":["compulsion", "need"],
        "gain": ["sexual gratification"],
        "victims": ["strangers", "fit a type"],
        "geographical": ["concentrated"],
        "crime_scene_traits": ["controlled crime scene", "overkill", "evidence of torture", "body moved", "specific victim", "aberrant sexual activity", "weapon of torture", "strangulation", "penile and object penetration", "necrophilia", "body mutilation after death"]
    },
     {
        "name": "mission",
        "methods": ["act-focused", "planned", "organized"],
        "metadata": [""],
        "motivation": ["compulsion", "personal belief", "cleansing"],
        "gain": ["sense of right", "worth", "good doing"],
        "victims": ["strangers", "random", "fit a type"],
        "geographical": ["concentrated"],
        "crime_scene_traits": [""]
    },
      {
        "name": "power",
        "methods": ["process-focused", "planned", "organized"],
        "metadata": [""],
        "motivation": ["power", "dominance"],
        "gain": ["absolute control over the victim"],
        "victims": ["strangers", "stalked", "fit type"],
        "geographical": ["dispersed"],
        "crime_scene_traits": ["controlled crime scene", "evidence of torture", "body moved", "specific victim", "aberrant sexual activity", "weapon of torture", "strangulation", "penile and object penetration", "necrophilia"]
    },
     {
        "name": "thrill",
        "methods": ["process-focused", "organized"],
        "metadata": [""],
        "motivation": ["personal", "sexual", "gratification"],
        "gain": ["terror", "pain"],
        "victims": ["strangers", "stalked", "fit type"],
        "geographical": ["dispersed"],
        "crime_scene_traits": ["controlled crime scene", "evidence of torture", "body moved", "specific victim", "aberrant sexual activity", "weapon of torture", "strangulation", "penile and object penetration"]
    },
     {
        "name": "visionary",
        "methods": ["act-focused", "spontaneous", "disorganised"],
        "metadata": [""],
        "motivation": ["psyche"],
        "gain": ["real", "perceived"],
        "victims": ["strangers", "random"],
        "geographical": ["concentrated"],
        "crime_scene_traits": [""]
    },
}
quit
aa = {
    {
        "name": "comfort",
        "methods": ["act focused", "planned", "organized"],
        "metadata": ["women also included in the group"],
        "motivation": ["power", "dominance"],
        "gain": ["material", "money"],
        "victims": ["known"],
        "geographical": ["concentrated"],
        "crime_scene_traits": ["controlled crime scene", "specific victim", "weapon at scene", "relational victim", "victim known"]
    },
     {
        "name": "lust",
        "methods": ["process-focused", "planned", "organized"],
        "metadata": [""],
        "motivation":["compulsion", "need"],
        "gain": ["sexual gratification"],
        "victims": ["strangers", "fit a type"],
        "geographical": ["concentrated"],
        "crime_scene_traits": ["controlled crime scene", "overkill", "evidence of torture", "body moved", "specific victim", "aberrant sexual activity", "weapon of torture", "strangulation", "penile and object penetration", "necrophilia", "body mutilation after death"]
    },
     {
        "name": "mission",
        "methods": ["act-focused", "planned", "organized"],
        "metadata": [""],
        "motivation": ["compulsion", "personal belief", "cleansing"],
        "gain": ["sense of right", "worth", "good doing"],
        "victims": ["strangers", "random", "fit a type"],
        "geographical": ["concentrated"],
        "crime_scene_traits": [""]
    },
      {
        "name": "power",
        "methods": ["process-focused", "planned", "organized"],
        "metadata": [""],
        "motivation": ["power", "dominance"],
        "gain": ["absolute control over the victim"],
        "victims": ["strangers", "stalked", "fit type"],
        "geographical": ["dispersed"],
        "crime_scene_traits": ["controlled crime scene", "evidence of torture", "body moved", "specific victim", "aberrant sexual activity", "weapon of torture", "strangulation", "penile and object penetration", "necrophilia"]
    },
     {
        "name": "thrill",
        "methods": ["process-focused", "organized"],
        "metadata": [""],
        "motivation": ["personal", "sexual", "gratification"],
        "gain": ["terror", "pain"],
        "victims": ["strangers", "stalked", "fit type"],
        "geographical": ["dispersed"],
        "crime_scene_traits": ["controlled crime scene", "evidence of torture", "body moved", "specific victim", "aberrant sexual activity", "weapon of torture", "strangulation", "penile and object penetration"]
    },
     {
        "name": "visionary",
        "methods": ["act-focused", "spontaneous", "disorganised"],
        "metadata": [""],
        "motivation": ["psyche"],
        "gain": ["real", "perceived"],
        "victims": ["strangers", "random"],
        "geographical": ["concentrated"],
        "crime_scene_traits": [""]
    }
}
aa = {
    {
        "name": "comfort",
        "methods": ["act focused", "planned", "organized"],
        "metadata": ["women also included in the group"],
        "motivation": ["power", "dominance"],
        "gain": ["material", "money"],
        "victims": ["known"],
        "geographical": ["concentrated"],
        "crime_scene_traits": ["controlled crime scene", "specific victim", "weapon at scene", "relational victim", "victim known"]
    },
     {
        "name": "lust",
        "methods": ["process-focused", "planned", "organized"],
        "metadata": [""],
        "motivation":["compulsion", "need"],
        "gain": ["sexual gratification"],
        "victims": ["strangers", "fit a type"],
        "geographical": ["concentrated"],
        "crime_scene_traits": ["controlled crime scene", "overkill", "evidence of torture", "body moved", "specific victim", "aberrant sexual activity", "weapon of torture", "strangulation", "penile and object penetration", "necrophilia", "body mutilation after death"]
    },
     {
        "name": "mission",
        "methods": ["act-focused", "planned", "organized"],
        "metadata": [""],
        "motivation": ["compulsion", "personal belief", "cleansing"],
        "gain": ["sense of right", "worth", "good doing"],
        "victims": ["strangers", "random", "fit a type"],
        "geographical": ["concentrated"],
        "crime_scene_traits": [""]
    },
      {
        "name": "power",
        "methods": ["process-focused", "planned", "organized"],
        "metadata": [""],
        "motivation": ["power", "dominance"],
        "gain": ["absolute control over the victim"],
        "victims": ["strangers", "stalked", "fit type"],
        "geographical": ["dispersed"],
        "crime_scene_traits": ["controlled crime scene", "evidence of torture", "body moved", "specific victim", "aberrant sexual activity", "weapon of torture", "strangulation", "penile and object penetration", "necrophilia"]
    },
     {
        "name": "thrill",
        "methods": ["process-focused", "organized"],
        "metadata": [""],
        "motivation": ["personal", "sexual", "gratification"],
        "gain": ["terror", "pain"],
        "victims": ["strangers", "stalked", "fit type"],
        "geographical": ["dispersed"],
        "crime_scene_traits": ["controlled crime scene", "evidence of torture", "body moved", "specific victim", "aberrant sexual activity", "weapon of torture", "strangulation", "penile and object penetration"]
    },
     {
        "name": "visionary",
        "methods": ["act-focused", "spontaneous", "disorganised"],
        "metadata": [""],
        "motivation": ["psyche"],
        "gain": ["real", "perceived"],
        "victims": ["strangers", "random"],
        "geographical": ["concentrated"],
        "crime_scene_traits": ["test"]
    }
}
aa = {"key-here": "val-here"}
aa = {"key-here": "val-here", "next": "sucks"}
aa = {{"key-here": "val-here", "next": "sucks"}, {"new": "thing"}}
aa = {{"key-here": "val-here", "next": "sucks"}{"new": "thing"}}
aa = {{"key-here": "val-here", "next": "sucks"}, {"new": "thing"},}
result
data_hash
quit
Type.all
show-models
quit
cd Hash
ls
word = "word"
word.to_s
word.symbolize_keys
cd
cd String
l
ls
quit
key
value
val
c
t
k
k.to_sym
t.update(k.to_sym => val)
t
val
c
t
val
t[:methods]
t[:methods] = []
t
@
t.update(k.to_sym => val[k.to_sym])
t
k
k.to_sym
val[k.to_sym]
v
c
@
t.update(k.to_sym => v)
t
t[:methods]
t[:methods].each {|a| puts a }
v
c
t
Type.all
Type.all.map {|a| a.delete }
quit
Type.all
quit
downloads
down = sub_dir(donwloads)
down = sub_dir(downloads)
quit
down = sub_dir(downloads)
down.map { |f| f.downcase; f.gsub([^(\w|\d|\.)], '-') }
down.map { |f| f.downcase }
down.map { |f| f.gsub([^(\w|\d|\.)], '-') }
down.map { |f| f.gsub(/[^(\w|\d|\.)]/, '-') }
c
q
down
down = sub_dir(downloads).map { |f| f.downcase; f.gsub(/[^(\w|\d|\.)]/, ' '); f.gsub(/_/, " ") }
down = sub_dir(down).map { |f| f.downcase; f.gsub(/[^(\w|\d|\.)]/, ' '); f.gsub(/_/, " ") }
down.map! { |f| f.downcase; f.gsub(/[^(\w|\d|\.)]/, ' '); f.gsub(/_/, " ") }
q
down
q
down
quit
q
down
q
down
q
down
q
down
q
cd string
String
cd String
ls
q
down
q
name
name.downcase!
name.gsub!(/[^(\w|\d|\.)]/, ' ')
name.gsub!(/(_| ){1,4}/, " ")
type = File.extname(file).split(/\./)[1]
File.join(name, '.' + type)
type = File.extname(file).split(/\./)[1]
name
dd = name + . + type
dd = name + '.' + type
q
name.gsub!(/[^(\w|\d|\.)]/, ' ')
name.gsub!(/(_| ){1,4}/, " ")
type = File.extname(file).split(/\./)[1]
first-part = File.basename(file).split(/\//)[4]
rt = File.basename(file).split(/\//)[4]
rt
File.basename(file).split(/\//)[2]
File.basename(file)
File(file)
File.(file)
file
file.split(/\//)[2]
file.split(/\//)[3]
File..expand_path(file)
File.expand_path(file)
File.expand_path(file).split(/\//)[3]
File.expand_path(file).split(/\//)
File.expand_path(file).split(/\//).pop
aa = File.expand_path(file).split(/\//)
aa
aa = File.expand_path(file).split(/\//).pop
aa
aa = File.expand_path(file).split(/\//)
aa.pop
aa.join("/")
c
q
name
filename = name '.' + type
q
@
file_renamed
file
q
@
file_renamed = clean_directory + filename
q
file_renamed = clean_directory + "/" + filename
q
file_renamed
File.extname(file).split(/\./)[1] =~ /part/
File.extname(file).split(/\./)[1]
q
YoutubeDL.download "https://www.youtube.com/watch?v=81wyj65SJIo", options
q
file = "~/Downloads/Clean/masters of the universe revelation official teaser netflix.json"
data_hash = JSON.parse(File.read(file))
file = "~/Downloads/Clean/masters\ of\ the\ universe\ revelation\ official\ teaser\ netflix.json"
data_hash = JSON.parse(File.read(file))
file = "~/Downloads/Clean/masters"
data_hash = JSON.parse(File.read(file))
q
file = "~/Downloads/Clean/masters"
@
File.read(file)
file = "~/Downloads/Clean/masters.json"
File.read(file)
require 'pry'
require 'json'
require "json"
file = "~/Downloads/Clean/masters.json"
data_hash = JSON.parse(File.read(file))
file = "/Users/shadowchaser/Downloads/Clean/masters.json"
File.read(file)
@
data_hash = JSON.parse(File.read(file))
@
data_hash['title']
data_hash['duration']
data_hash['description']
data_hash
data_hash.keys
data_hash['tags']
data_hash['channel']
data_hash['subtitles']
dir
filepaths
subtitle_path
sub_dir(dir)
filepaths[name][type] = file
filepaths
c
q
filepaths[name][type] = file
filepaths
q
filepaths
q
filepaths
q
filepaths
filepaths['masters']
filepaths['masters']['json']
cd YoutubeDl
ls
youtube.filepaths
quit
v
v['json']
cd Hash
l
ls
fp = @filepaths.deep_symbolize_keys
@filepaths
fp = @filepaths.deep_symbolize_keys
result
data_hash['url']
data_hash.keys
data_hash['id']
data_hash['uploader_url']
http://www.youtube.com/watch?v=DwX4fwYJlWg@
@
result
result.keys
data_hash['title']
data_hash['title'].squeeze
data_hash['title'][1]
data_hash['title'][0]
data_hash['title'][0].class
cd String
ls
cd
data_hash['title'][0].chars
data_hash['title'][0].bytes
data_hash['title'][0].pop
@
data_hash['title'][0].squeeze
data_hash['title'].squeeze
data_hash['title'].lstrip
data_hash['title'].strip
aa = " string "
aa.strip
result
data_hash
result
q
result
quit
attr
attr.downcase!
attr.empty?
attr.present?
attr.exists?
attr.exists
attr.class
youtube.clean_attribute(result[k]['title'])
attr
result[k]['title']
title = youtube.clean_attribute(result[k]['title'])
attr
q
result
quit
result
quit
results
result
result['A Wrinkle in Time (Ted Lasso)']
@
result['A Wrinkle in Time (Ted Lasso)']
result['ted lasso  season 2 official teaser apple tv']
@
result['ted lasso  season 2 official teaser apple tv']
l
ls
la
l
@
user
youtube_subtitles(user[0])
downloads
filestack = sub_dir(downloads)
downloads
sub_dir(downloads)
downloads
ENV['HOME']
downloads = File.join("home", 'Downloads/Images/')
home
filestack = sub_dir(downloads)
q
file
get_image(user[0])
user.scan(/\.(png|jpg)/)
user
user.join
user.join.scan(/\.(png|jpg)/)
"https://i.ytimg.com/vi/NLo7-XEpN44/hq720.png".scan(/\.(png|jpg)/)
"https://i.ytimg.com/vi/NLo7-XEpN44/hq720.png".scan(/\.(png|jpg)/).flatten
"https://i.ytimg.com/vi/NLo7-XEpN44/hq720.pngs=search/jpg".scan(/\.(png|jpg)/).flatten
"https://i.ytimg.com/vi/NLo7-XEpN44/hq720.pngs=search.jpg".scan(/\.(png|jpg)/).flatten
aa = []
aa.count
aa = ""
aa.count
aa.length
aa = []
aa.length
aa = "somestring"
aa.scan(/jpg/)
link
link[0]
agent.get(link[0].save "/Users/shadowchaser/Downloads/Images/#{File.basename(url)}"
!
agent.get(link[0].save "/Users/shadowchaser/Downloads/Images/#{File.basename(url)}"
agent.get(link[0]).save "/Users/shadowchaser/Downloads/Images/#{File.basename(url)}"
agent.get(link).save "/Users/shadowchaser/Downloads/Images/#{File.basename(link)}"
q
filestack
filestack.any?
filestack
filestack.select { |file| file if File.extname(file) =~ /\.(png|jpg|tiff|giff)/ }
q
filestack.include?(File.basename(link[0]))
filestack.include?(image_complete)
image_complete
system("open #{image_complete}")
image_complete
image_complete.class
Type.all
unfilterd_subtitles
unfilterd_subtitles.map { |path| path if File.extname(file).split(/\./)[1] != /(\.srt|\.vtt)/ }
unfilterd_subtitles.map { |file| file if File.extname(file).split(/\./)[1] != /(\.srt|\.vtt)/ }
aa = unfilterd_subtitles.map { |file| file if File.extname(file).split(/\./)[1] != /(\.srt|\.vtt)/ }
aa
aa = unfilterd_subtitles.map { |file| file if File.extname(file).split(/\./)[1] =~ /(\.srt|\.vtt)/ }
"/Users/shadowchaser/Downloads/Movies/Everything Wrong With Blade Runner 2049.en.vtt"
aa = "/Users/shadowchaser/Downloads/Movies/Everything Wrong With Blade Runner 2049.en.vtt"
File.extname(aa).split(/\./)[1] =~ /(\.srt|\.vtt)/
aa
File.extname(aa)
File.extname(aa)split(/\./)[1]
File.extname(aa).split(/\./)[1]
aa = unfilterd_subtitles.map { |file| file if File.extname(file).split(/\./)[1] =~ /(srt|vtt)/ }
aa.flatten
aa = unfilterd_subtitles.select { |file| file if File.extname(file).split(/\./)[1] =~ /(srt|vtt)/ }
aa = [1,2,3,4,5]
aa.any?
aa = []
aa.any?
aa = [nil]
aa.any?
filterd_json = unfilterd_subtitles.select { |file| file if File.extname(file).split(/\./)[1] =~ /json/ }
filterd_subs = unfilterd_subtitles.select { |file| file if File.extname(file).split(/\./)[1] =~ /(srt|vtt)/ }
subs
json
c
q
sub_dir(movies)
sub_dir(movies).any?
c
q
sub_dir(movies).any?
sub_dir(movies)
sub_dir(movies).any?
sub_dir(movies)
q
Dir.exist?(movies)
aa = "~/.bin/wang"
aa
Dir.exist?(aa)
q
Dir.exist?(movies)
q
aa = [1,2,3,4,5]
if 1 not in aa
cd Array
l
ls
xs
cd
quit
Type.all
:Q
quit
result
l
@
data_hash
quit
c
l
Type.all
quit
c
my_group = Type.find_or_create_by(name: key)
key
c
@
k
key
value
k
v
my_group.update(k => v)
my_group
Type.all
quit
Type.all
quit
cd String
ls
quit
file_data
file_data.split(" ")
posative = ["good", "happy"]
file_data.split(" ").each {|word| posative.include?(word) }
posative = ["good", "happy", "helps"]
file_data.split(" ").select {|word| posative.include?(word) }
file_data.join("\n")
file_data
file_data.split(" ").join
file_data.split(" ").join(" ")
file_data.split(" ").join(" ").scan
file_data.split(" ").join(" ").scan(/shade against cliffs/)
person_list
@
person_list.store("django")
person_list.store("dave")
person_list.store("daz")
person_list.store("dipper")
person_list.flatten
person_list.compact
l
quit
aa = ["bb", "aa"]
aa.each {|attr| attr }
Type.all
Category.all
Articles.all
Article.all
quit
Category.all
quit
User.all
quit
Article.map {|a| a.delete }
Article.all.map {|a| a.delete }
quit
Article.all
Article
quit
User
User.create(username: :shadow, email: shadow@google.com)
User.create(username: :shadow, email: :shadow@google.com)
User.create(email: :shadow@google.com)
User.create(username: :shadow, email: :"shadow@google.com")
quit
User.create(username: :shadow, email: :"shadow@google.com")
User.create(email: :"shadow@google.com")
quit
User.create(username: :shadow, email: :"shadow@google.com")
User.find_or_create_by(username: :shadow, email: :"shadow@google.com")
User.find_or_create_by(email: :"shadow@google.com")
quit
User.find_or_create_by(username: :shadow, email: :"shadow@google.com")
quit
User.all
User.first.update(username: :shadow)
User.all
quit
Article.all
Article
quit
@
current_admin_user
article_params
Article.all
Article
urrent_admin_user.articles.new(article_params)
current_admin_user.articles.new(article_params)
current_admin_user.articles.new(article_params).save
@
article_params)
article_params
current_admin_user.articles.count
current_admin_user.articles
@article = current_admin_user.articles.new(article_params)
@article.save
User.first
User.first.articles
User.first.articles.count
@
c
Article.create(title: "test", category_id: 1, user_id: 1)
User.first.articles.create(title: "test", category_id: 1)
quit
Category.first
Category.first.atricles
Category.first.articles
Category.first.articles.create(title: :test)
Category.first.articles
aa Category.first.articles.create(title: :test)
aa = Category.first.articles.create(title: :test)
aa.save
aa Category.first.articles.create(title: :test,user_id: 1)
aa = Category.first.articles.create(title: :test,user_id: 1)
aa.save
Category.first.articles.create(title: :test)
quit
@
current_admin_user
current_admin_user.articles
current_admin_user.articles.count
article_params
current_admin_user.articles.new(article_params)
Category.all
c
quit
@
@article = current_admin_user.articles.new(article_params)
@article.save
article_params
@article
@article.id = 1
@article
@article.save
@article.id = 10
@article.save
quit
@
@article = current_admin_user.articles.new(article_params)
article_params
current_admin_user.articles
User.last
User.last.articles
User.last.articles.create(title: :"some name", category_id: 1)
qui
quit
User.last
User.last.articles
User.last.articles.create(title: :"some name", category_id: 1)
Category.first
Category.first.articles
Category.first.articles.create(title: :"twat")
Category.first.articles.create(title: :"twat", user_id: 1)
quit
@
:q
quit
Category.first
Category.all
quit
Category.first
Category.first.articles.count
Category.first.articles.create(title: :"this sucks big time", content: :"i hate when things do not work")
Category.find(1)
Category.find(2)
Category.find(3)
Category.first.articles
Category.first.articles.create(title: :"work you twat", content: :"i hate when things do not work")
Category.first.articles
quit
Category.first
Category.first.articles
Article.all.map {|a| a.destroy }
quit
Article
quit
User.first
User.create(name: :shadow, email: :"shadow@google.com")
User.first
User.first.articles
User.first.articles.create(title: :work, category_id: 1, content: :"this sucks")
quit
User.first
User.find(2)
User.find(3)
quit
article_params
@
article_params
current_admin_user
current_admin_user.articles
current_admin_user.articles.count
@
@article = current_admin_user.articles.create(article_params)
@article = current_admin_user.articles.build(article_params)
quit
User.first.articles
User.first.articles.create(title: :work, category_id: 1, content: :"this sucks")
User.first.articles
quit
Category.all
Category.create(name: :reviews)
Category.create(name: :news)
Category.create(name: :new releases)
Category.create(name: :"new releases")
Article.all
quit
Article.all
quit
@
@article_category = Category.find_by(id: @article.category_id)
c
Article.all
quit
Article.all
quit
Article.first
Article.first.images
Article.first.pictures
Picture
quit
Article.first
Article.all
User.all
Article.all
Picture.all
quit
Picture.all
quit
Picture.all
Picture
cd String
ls
@
category_attributes
category_attributes.count
c
@
category_attributes.count
c
@
@articles = category_attributes.published.most_recent
@articles
category_attributes
params[:category]
c
ActionController::Base.helpers.asset_path('icon.png')
ActionController::Base.helpers.asset_path('log.jpeg')
quit
User.all
quit
Article.last
Article.last.pictures
Article.last.pictures.name
quit
@
current_admin_user
current_admin_user.pictures
@
@user = current_admin_user
@user
@user.pictures
@user.pictures.first
@user.pictures.first.name
c
category_name(2)
Category.first
Category.find(1)
Category.find(1).name
params
@
params
q
c
Category.first
Category.all
quit
Article.all
Article
Category.create(name: :news)
Category.create(name: :reviews)
Category.create(name: :trailers)
quit
@
params
c
params
c
params
params[:action]
params[:controller] == "admin/users/registrations" && params[:actions]  == "edit"
params[:controller]
params[:controller] == "admin/users/registrations"
params[:actions]  == "edit"
params[:controller] == "admin/users/registrations" && params[:action]  == "edit"
c
User.all
quit
aa = [1,2,3,4,5]
rand(1..5)
Article.all
Article.first.pictures
Article.last
Article.last.pictures
@
Article.create(title: :fun, content: :"this is fun").pictures.create(name: :fun)
Article.create(title: :fun, content: :"this is fun")
Article.create(title: :fun, content: :"this is fun",user_id: 1, category_id: 1)
Article.create(title: :fun, content: :"this is fun",user_id: 1, category_id: 1).pictures.create(name: :test)
User.all
:q
quit
c
Article.count
Article.all
c
Article.all.count
quit
Article.all.map {|a| a.destroy }
quit
Article.all.count
quit
Article.all.map {|a| a.destroy }
exit
base = 16
scale = 1.3
base * scale * scale
base * scale
base = 1
base * scale
base * scale * scale
base * scale^2
base * scale * 2
base * scale
base * scale
scale = 1.250
base * scale
base * scale * scale
aa = scale * 2
base ** scale
base * scale ** 3
base * scale ** 2
base * scale ** 4
base * scale ** 5
(base * scale ** 5).rounded
base * scale ** 5 
Category.all
Category
quit
Article.all
quit
Article.all
quit
Article.first.pictures
quit
Aticle.all
Article.all
quit
@
art = Article.create(title: title[rand(1..10)], content: text[0], category_id: rand(1..2), user_id: 1, published: true)
art.save
Category.create(name: :movie)
Category.find(3).pictures
User.create(username: :shadow, email: :"shadow@google.com")
quit
User.create(username: :shadow, email: :"shadow@google.com")
quit
User.create(username: :shadow, email: :"shadow@google.com")
quit
base = 24
scale = 1.25
base * scale ** 3
scale = 1250
scale = 1.250
base * scale ** 3
base * scale ** 4
base * scale ** 5
quit
scale = 1.25
quit
User.all
User.create(username: :shadow, email: :"shadow@gmail.com")
quit
User.create(username: :shadow, email: :"shadow@gmail.com")
User.find_or_create_by(username: :shadow, email: :"shadow@gmail.com")
pkaj
quit
User.find_or_create_by(username: :"shadow", email: :"shadow@gmail.com")
l
quit
User.find_or_create_by(username: :"shadow", email: :"shadow@gmail.com")
Article.all
quit
Article.where(published: false)
Article.where(published: false).first
Article.where(published: false).first.update(published: true)
quit
User.all
quit
Article.all
User.create(username: :shadow, email: :"shadow@google.com")
quit
Article.map {|art| art if art.pictures.present? }
Article.all.map {|art| art if art.pictures.present? }
Article.all.map {|art| art.destroy if !art.pictures.present? }
quit
Label.all
Artist.all
Artist.create(name: :"dj topgroove")
Artist.find(1)
Artist.find(1).labels
quit
Artist.create(name: :"dj craze")
Artist.create(name: :"force and styles")
Artist.create(name: :"dj sy")
Artist.create(name: :"dj dougal")
Artist.count
quit
Artist
Artists
quit
Artist.all
quit
Artists
Artist
Artist.create(name: :"dj topgroove")
Artist.create(name: :"dj sy")
Artist.create(name: :"dj dougal")
Artist.create(name: :"force and styles")
Artist.create(name: :"dj craze")
Artist.first
Artist.first.pictures
quit
Artist.first.pictures
quit
pictures.all
picture.all
Picture.all
quit
Artist.all
quit
Artist.last
Artist.last.labels
quit
Label.all
Label
Artist
quit
Label
Article
quit
User.first
User.first.articles
quit
Article.all
quit
Artists.first
Artist.create(name: :sy)
Artist
quit
Artist.create(name: :"dj topgroove")
Artist.first
Artist.first.labels
quit
Artist.first.labels
quit
Label
Label.create(name: :"posativa")
Label.create(name: :"capital records")
Label.create(name: :"bonzi records")
Label.create(name: :"trance syndicate")
quit
Artist.create(name: :"dj sy").labels.find_or_create_by(name: :posativa)
Label.all
Label.where(name: :posativa)
Artist.first.labels
Artist.first
Artist.last
Artist.last.labels
Artist.last.labels.where(name: :posativa)
quit
Artist.map {|a| a.destroy unless a.pictures.first.present? }
Artist.all.map {|a| a.destroy unless a.pictures.first.present? }
managment.all
Managment.all
Managment.map {|a|  a.destroy}
Managment.all.map {|a| a.destroy}
Article.all.map {|a| a.destroy }
Artist.all.map {|a| a.destroy }
Label.all.map {|a| a.destroy }
quit
Artist.last
Artist.last.pictures
Artist.last.labels
Artist.last.labels.name
Artist.last.labelsquit
quit
Artist.last.labels {|a| a.name }
Artist.last.labels.each {|a| a.name }
Artist.last.labels.each {|a| a[:name] }
Artist.last.labels
Artist.last.labels.each {|a| a[:name] }
Artist.last.labels.pluck(:name)
quit
@
n
l = Label.where(name: n.strip).first_or_create!
Label.all
l
l.pictures
l.pictures.create(name: :dong)
l.pictures.first.present?
l
l.name = nil
l.save
l
l.name = ministry of sound
l.name = "ministry of sound"
l
l.pictures
c
l.pictures
c
l.pictures
n
c
Label
Label.all
Label.find(13)
Label.find(13).pictures
l
c
pictures.all
Picture.all
Picture.where(imageable_type: :label)
Picture.where(imageable_type: :Label)
Managment.all.map {|a| a.destroy }
quit
Labels
quit
Artist.first
Artist.first.labels
Label.all
Label
Article
quit
Artist.first.labels
quit
Artist.first.labels
quit
Label
Article
quit
Artist.first.labels
quit
Label
Label.create(name: :"ministry of sound")
Label.create(name: :"skint records")
Label.create(name: :"slamm records")
quit
Label.create(name: :"rca records")
Label.create(name: :"warner records")
Label.create(name: :"columbia label group")
Label.create(name: :"capitol music")
Label.create(name: :"republic records")
Label.create(name: :"atlantic records")
Label.create(name: :"warner music")
Label.create(name: :"sony music entertainment")
Label.create(name: :"universal music")
l
quit
Label.all.map {|a| a.destroy }
quit
Artist
quit
Categor.all
Category.all
Category.first
Category.first.articles
User.all.map {|a| a.destroy }
Article.all.map {|a| a.destroy }
Category.all.map {|a| a.destroy }
quit
Article
quit
Article.all
User.all
Category
Category.all
quit
Article.create(title: :twat, category_id: 1, user_id: 1)
quit
Article.create(title: :twat, category_id: 1, user_id: 1)
Admin::Article.create(title: :twat, category_id: 1, user_id: 1)
Admin::rticle.create(title: :twat, category_id: 1, user_id: 1)
Admin::article.create(title: :twat, category_id: 1, user_id: 1)
Article.all
quit
Article.create(title: :twat, category_id: 1, user_id: 1)
Article.create(title: :twat, category_id: 1, user_id: 1, content: :"this is some text that is here")
Article.create(title: :twat, category_id: 1, user_id: 1, content: :"this is some text that is here", published: true)
quit
Category.all
Admin::Category.all
quit
Admin::Category.all
Admin::Articles
Admin::Article
Admin::Article.all
Admin::Article.create(title: :mindhunter)
Admin::Category.create(title: :"mindhunter")
Admin::Category.create(name: :"mindhunter")
Admin::Category.create(name: :"hannible")
Admin::Article.create(title: :mindhunter, category_id: 1)
quit
Admin::Article.create(title: :mindhunter, category_id: 1)
Admin::Category.create(name: :"red dragon")
aa = Admin::Article.create(title: :mindhunter, category_id: 1)
aa.save
Admin::Article.create(title: :mindhunter, category_id: 1).categories
Admin::Category.first
Admin::Category.first.articles
quit
Admin::Category.all
Admin::Article.all
Admin::Article.create(title: :"new", category_id: 1)
Admin::Category.create(name: :"mindhunter")
Admin::Category.create(name: :"hannible")
Admin::Article.create(title: :"new", category_id: 1)
quit
Admin::Category.create(name: :"mindhunter")
Category.create(name: :"mindhunter")
quit
show-models
quit
Admin::Category.create(name: :news)
Admin::Category.create(name: :reviews)
quit
models-show
model-show
show-models
Admin::Category.all
quit
params
ls
as_json
pretty_print
q
params
c
@
params
c
params
params[:action]
c
quit
c
quit
show-models
Admin::Article.last
Admin::Article.create(title: :"why i love movies")
Admin::Article.find_by(title: :"why i love movies")
Admin::Article.find_by_title(title: :"why i love movies")
Admin::Article.find_by_title("why i love movies")
Admin::Article.where(title: :"why i love movies")
Admin::Article.find(1)
Admin::Article.find(1..2)
Admin::Article.find(3)
Admin::Article.find(3).first
Admin::Article.where(title: :"why i love movies").first
Admin::Article.where(title: :"why i love movie").first
quit
Admin::Article.find(1)
quit
Article.all
quit
Article
Article.all
Article.find_or_create_by(title: title[rand(1..10)], content: text)
c
Article.all
quit
Article.all.map {|a| a.published = true }
quit
show-models
quit
Article
quit
Category.create(name: :news)
Category.create(name: :reviews)
quit
Article
Category
quit
@
Article.find_by_slug(params[:slug])
Article.find_by_slug(params[:id])
Article.find_by(params[:slug])
c
Article.last
Article.first
quit
Article.last
Article.last.destroy
Article.last
quit
Article.last.destroy
Article.last
quit
Article.last
Article.create(title: :"why i love movie")
Article.create(title: :"why i love movie", category_id: 1)
Article.create(title: :"why i love movie", category_id: 1, slug: :"why i love movie")
quit
Article
Article.create(title: :new, category_id: 1)
Article.create(title: :new, category_id: 1, slug: :new)
Article.create(title: :"new one", category_id: 1, slug: :"new one")
Article.create(title: :"new two", category_id: 1)
Article.create(title: :"new three", category_id: 1)
Article.all
quit
@
params
c
params
c
params
c
Article.all
@
params
c
params
c
Article.all
quit
@
ls
@attributes
@
@attributes
update slug: assign_slug
self.update slug: assign_slug
@
@attributes
assign_slug
@attributes.slug = assugn_slug
@attributes.slug = assign_slug
@attributes["slug"] = assign_slug
@attributes
@
@attributes
!
@attributes
c
cc
c
@attributes
@attributes]["slug"] = 1
@attributes["slug"] = 1
@attributes
@attributes["slug"] = "some-text"
@attributes["slug"]
@attributes
@attributes.save
c
quit
Category.create(name: :news)
Category.create(name: :reviews)
quit


app.article_path Article.last
app.article_path Article.last
quit
aa = "11-this-name1"
aa.to_i
aa = "this-11-name"
aa.to_i
c
quit
Category.create(name: :news)
Category.create(name: :reviews)
ls
@attributes
slug
id
c
show-models
Subtitle.all
YoutubeResult.all
Football.all
Auditory.all
quit
root = Rails.root.join('lib/data').to_s
c
@
name = File.basename(file,File.extname(file))
c
Rails.application.eager_load!
Rails.application.strict_load
Rails.application.strict_loading
Rails.application.strict_loading?
Rails.application.eager_load!
show-models
Football.all
quit
Football.all
Audiatory.all
Auditory.all
quit
filepaths = sub_dir(root)
@
Rails.application.class
Rails.application.class.parent
ls
cd Rails.application.class
ls
find_root
Rails.application.class.find_root
cd
Rails.application.class.find_root
Rails.application.class.engine_name
app_name = Rails.application.class.engine_name.to_s.underscore
c
Audiatory.all
Auditory.all
quit
Football.all
quit
Subtitle.al
Subtitle.all
YoutubeResult.all
quit
YoutubeResult.all
Subtitle.all
quit
Subtitle.all
YoutubeResult.all
quit
Subtitle.all
YoutubeResult.all
YoutubeResult.first
YoutubeResult.first.subtitles
quit
YoutubeResult.first.subtitle
YoutubeResult.first
YoutubeResult.first.subtitle
User.all
User.first
User.first.youtube_results
User.first.youtube_results.subtitle
User.first.youtube_results.first.subtitle
User.first.youtube_results.first.subtitle.keys
User.first.youtube_results.first.subtitle.pluck(:paragraph)
User.first.youtube_results.first.subtitle
User.first.youtube_results.first.subtitle.pluck(:title)
User.first.youtube_results.first.subtitle
User.first.youtube_results.first.subtitle[:paragraph]
User.first.youtube_results.first.subtitle[:paragraph].keys
l
ls
@
User.first.youtube_results.first.subtitle[:paragraph].keys
User.first.youtube_results.first.subtitle
User.first.youtube_results
ls
@
User.first
quit
Category.all
quit
Category.all
quit
Category.all
quit
Article.all
quit
c
Article.all
quit
Article.all.map {|a| a.destroy }
Article.all
Picture.all
Picture.all.map {|a| a.destroy }
quit
c
@
params[:category]
params
c
@
params[:category]
paginate
params[:page]
c
@
params
c
@
params
params[:page] ||= params[:page] = 1
c
@
params[:page]
params[:page] ||= params[:page] = 1
c
params[:category]
params
c
scale = 1.250
base = 23
base = 24
base * scale
base * scale ^2
base * scale **2
base * scale ** 2
base * scale ** 1
base * scale ** 2
base * scale ** 3
base * scale ** 5
base * scale^ 5
base * scale^5
base * scale ^ 5
base * scale ** 5
quit
Article.all.map {|a| a.destroy }
Picture.all.map {|a| a.destroy }
quit
Article.last.destroy
l
quit
c
Category.all
Article.first
quit
cd Array
l
ls
quit
scale = 1.250
base = 24
scale * base ** 1
scale * base ** 2
scale * base ** 3
base * scale ** 3
base * scale ** 2
base * scale ** 1
base * scale ** 2
base * scale ** 3
quit
root = 16
scale = 1.250
root * scale ** 1
root * scale ** 2
root * scale ** 3
quit
person_list.store("tyson")
person_list.store("david")
person_list.store("dave")
person_list.store("mic")
person_list.store("mike")
person_list.store("mel")
person_list.compact
cypher.unencrypt(mykey)
mykey = cypher.encrypt("nosey twats")
mykey
cypher.unencrypt(mykey)
Type.all
show-models
quit
q
show-models
Type.all
aa = ["this is cool", "this", "cool", "this is cool", "this is not cool"]
aa.scan(/this is cool/)
aa.flatten
aa.join
aa.join(" ")
aa.join(" ").scan(/this is cool/)
aa.join(" ").scan(/this is cool/).count
l
@
n
q
@
create_filepaths
youtube.create_filepaths
q
file
data_hash = JSON.parse(File.read(file["json"]))
File.read(file)
data_hash = JSON.parse(File.read(file["json"]))
data_hash = JSON.parse(File.read(file))
q
show-models
Downloads.count
Download.count
Download.find(1)
Download.find(2)
Download.find(3)
Download.find(4)
Download.find(5)
Download.find(6)
Download.map {|a| a.delete }
Download.all.map {|a| a.delete }
Download.count
quit
Download.count
Download.first
Download.find(1)
Download.all.find(1)
Download.all.find(83)
Download.all.find(84)
Download.all.find(85)
quit
Download.count
quit
Download.all.find_by(title: "some name").any?
Download.all.find_by(title: "some name")
Download.all.find_by(title: "some name").present?
Download.all.find_by(title: "some name").exists?
Download.all.find_by(title: "some name").any?
quit
Download.count
Download.all.find(1)
quit
Download.count
quit
Download.all.map {|a| a.delete}
Download.all
quit
Download.count
quit
Download.all.map {|a| a.delete}
quit
base = 16
scale = 1.250
base * scale **2
base * scale ^2
base * scale**2
base * scale**3
base * scale**4
base * scale**5
quit
Article.all
quit
<%= params[:controller].parameterize %>
params
n
params[:actions]
params
nn
n
quit
Article.all
Category.all
quit
Pictures.all
Picture.all
quit
Article.all
quit
Article.all
Article.last
Article.last.pictures
quit
Article.all.map {|a| a.destroy }
quit
Picture.all
Picture.all.map {|a| a.destroy }
quit
scale = 1.250
base = 16
base * scale^2
base * scale**2
base * scale**3
base * scale**4
quit
base = 16
scale = 1.250
base * scale**4
def power(pow)
$base = 16
$scale = 1.250
return $base * $scale**pow
end
power(1)
power(3)
power(4)
quit
Category.create(name: news)
Category.create(name: :news)
Category.create(name: :reviews)
quit
Article.all.first
Article.all.first.title
quit
Category.all
quit
params
@
ls
params
params[:controller]
param[:controller]
quit
ls
value
@
params
param
@
params[:controller]
q
"i like finding sentences in long strings".scan(/like finding/)
quit
aa = ["Gray", "November"]
aa.split
aa.join
aa.join.split(/ /)
aa.join(" ").split(/ /)
aa.join(" ")
quit
data
quit
data
quit
c
data
data[:lyrics]
data["lyrics"]
quit
c
line
line.split
quit
c
ls
lines_hash
c
lines_hash
quit
aa = {}
quit
data[:lyrics].count
data[:lyrics]
data["lyric"]
data["lyrics"]
data["lyrics"].count
data["lyrics"].join(" ")
data["lyrics"].join(" ").split
data["lyrics"].join(" ").split.count
c
ls
lines_hash
c
lines_hash
quit
c
lines_hash
quit
aa = {}
aa
aa[:test]
aa[:test].count
aa[:test].length
quit
c
lines_hash[:longest_syllable] == nil
c
lines_hash[:longest_syllable]
lines_hash[:longest_syllable].class
lines_hash[:longest_syllable].size
lines_hash[:longest_syllable].count
@
if lines_hash[:longest_syllable].length < 0; puts "eat shit"; end
if lines_hash[:longest_syllable] < 0; puts "eat shit"; end
if lines_hash[:longest_syllable] == 0; puts "eat shit"; end
quit
c
lines_hash
c
cc
c
lines_hash
c
lines_hash
c
lines_hash
quit
c
lines_hash
quit
c
lines_hash
quit
lines_hash = Hash.new(0)
lines_hash = Hash.new(0) { |h, k| h[k] = Hash.new }
quit
c
lines_hash
quit
c
lines_hash
c
lines_hash
quit
c
lines_hash
quit
c
per
@
lines_hash[:syllables].each { |k, v| lines_hash[:percentages][":" + "#{v}"] = v / per[:words_count] * 100 }
v / per[:words_count] * 100
240 / per[:words_count] * 100
(240 / per[:words_count] * 100)
per[:words_count]
240 / per[:words_count]
(240 / per[:words_count])
per[:words_count]
240 / 331
(240 / 331).to_f
240 / per[:words_count].to_f
(240 / per[:words_count].to_f) * 100
quit
c
lines_hash
quit
c
lines_hash
qui
quit
c
lines_hash
quit
c
lines_hash
qui
quit
c
puts "#{divide}"
c
cd Hash
ls
quit
c
lines_hash[:words_count]
lines_hash[:words_count].key
lines_hash[:words_count].key?
cd Hash
ls
cd
lines_hash[:words_count].key
lines_hash.keys?
lines_hash.keys
l
ls
quit
c
lines_hash.keys
blacklist
blacklist.include?(lines_hash.keys[1])
blacklist.include?(":" + lines_hash.keys[1])
blacklist.include?(":" + "#{lines_hash.keys[1]}")
lines_hash.keys[1]
lines_hash.keys[1].to_s
blacklist.include?("#{lines_hash.keys[1].to_s}")
quir
quit
c
blacklist.include?("#{lines_hash.keys[1]}")
blacklist
lines_hash.keys[1]
blacklist.include?("#{lines_hash.keys[1]}")
blacklist.include?(lines_hash.keys[1])
quit
c
value
key
c
key
value
lines_hash.keys
blacklist
main_key
blacklist.include?(main_key)
blacklist.include?(":" + lines_count)
blacklist.include?(":" + "lines_count")
c
main_key
key
c
lines_hash[:main]
lines_hash[main_key]
c
@
local_files = sub_dir(root)
File.extname(f)
File.extname(root)
File.extname(#{root})
!
@
root
f = "/Users/shadowchaser/Code/Ruby/Projects/lyrics/champaigne-problems.json"
quit
local_files = sub_dir(root)
    32:
    33: local_files.each { |f| puts f if File.extname(f) == "json" }
@
local_files = sub_dir(root)
root = "/Users/shadowchaser/Code/Ruby/Projects/lyrics"
local_files = sub_dir(root)
local_files.each { |f| puts f if File.extname(f) == "json" }
ff = "/Users/shadowchaser/Code/Ruby/Projects/lyrics/champaigne-problems.json"
ff
File.extname(f)
File.extname(ff)
c
f.split(/\./)[1]
f.split(/\./)[0]
f.split(/\//)
f.split(/\//)[-1]
quit
user = gets
f.split(/\//)[-1]
c
ls
files_array
c
0
1
u
user = files_array[u.to_i]
c
1.class
index
index.class == Integer
0.class == Integer
(0..files_array.count)
(0..files_array.count - 1)
index.class == Integer
index
a.to_i
a.to_i.class
a.to_i.class == Integer
quit
c
search_term = files_array[u.to_i]
files_array.include?(search_term)
files_array[u.to_i]
u
u.to_i
u
/[0-9]/ == u
u
/[0-9]/ =~ u
/[0-9]/ =~ "a"
c
(/[0-9]/).match(index)
(/[0-9]/).match("a")
files_array.include?(files_array[index.to_i])
files_array.include?(files_array[1.to_i])
c
file
data = JSON.parse(File.read(file))
c
lines_hash["longest_syllable"]
lines_hash
lines_hash["longest_syllable"]
c
lines_hash.deep_symbolize_keys
cd Hash
ls
@
cd
@
cheat
@
lines_hash.symbolize_keys
lines_hash.transform_keys(&:to_sym)
cd Hash
ls
c
first
lines_hash["words_count"]
lines_hash["syllables_count"]["total"]
first.to_f
lines_hash["words_count"].to_f / lines_hash["syllables_count"]["total"].to_f
first - second
c
(206.835 - first)
(206.835 - first) - second
206.835 - first - second
206.835 - first
201.0292 - second
second
quit
second
result = ((206.835 - first) - second)
first
lines_hash["words_count"].to_f / lines_hash["lines_count"].to_f
5.72 * 1.015
(lines_hash["syllables_count"]["total"].to_f / lines_hash["words_count"].to_f * 84.6)
206.835 - first
201.0292 - second
result = ((206.835 - first) - second).round(3)
result = ((206.835 - first) - second).limit(3)
cd Integer
ls
cd
result = ((206.835 - first) - second).truncate(3)
result = ((206.835 - first) - second)
result
result.round(3)
quit
ls
local_files
local_files.map! { |f| f.pop unless File.extname(f) == ".json" }
cd Array
ls
cd
@
local_files.map! { |f| f.delete unless File.extname(f) == ".json" }
local_files.map! { |f| if  File.extname(f) == ".json" }
local_files.map! { |f| if File.extname(f) == ".json" }
local_files.map! { |f| File.extname(f) == ".json" }
!
local_files.map! { |f| File.extname(f) == ".json" }
local_files
local_files.keep_if { |f| File.extname(f) == ".json" }
local_files
quit
l
quit
:q
lines_hash["longest_syllable"].blank?
lines_hash["longest_syllable"]
@
line.split
line.split.count
lines_hash["percentages"]
lines_hash["percentages"].count
ls
lines_hash
quit
c
word
c
word
c
word
c
word
c
word
c
data
quit
data
quit
@
word
word.length
c
average_sentence_length
1.015 * average_sentence_length
206.835 - (1.015 * average_sentence_length)
206.835 - 1.015 * average_sentence_length
(206.835 - 1.015 * average_sentence_length - 84.6 * average_syllable_per_word)
(206.835 - (1.015 * average_sentence_length) - (84.6 * average_syllable_per_word))
c
"this is a long sentence".scan(/long sentece/)
"this is a long sentence".scan("/long sentece/")
"this is a long sentence".scan(/"long sentece"/)
"this is a long sentence".scan(/long/)
"this is a long sentence".scan(/long sentence/)
quit
@
data["lyrics"]
data["lyrics"].join("\n")
data["lyrics"].join("\n").chomp
data["lyrics"].join("\n").join(" ")
data["lyrics"].join("\n").split(" ")
data["lyrics"].join("\n").split(" ").join
data["lyrics"].join("\n").split(" ").join.count
data["lyrics"].join("\n").split(" ").join("").count
data["lyrics"].join("\n").split(" ").join("")
data["lyrics"].join("\n").split(" ").join("").length
data["lyrics"].join("\n").split(" ").join("").length.gsub(/[^a-zA-Z]/)
data["lyrics"].join("\n").split(" ").join("").gsub(/[^a-zA-Z]/)
data["lyrics"].join("\n").split(" ").join("").gsub(/\W/)
aa = data["lyrics"].join("\n").split(" ").join("")
aa.gsub(/[^a-zA-Z]/)
aa.gsub(/[^a-zA-Z]/, "")
10*10
@
lines["syllables"]
lines["syllables"].sort
lines["syllables"].sort.to_h
lines["syllables"].sort.to_h.to_s
lines["syllables"].sort.to_h.to_sym
cd Hash
ls
cd
lines["syllables"].sort.to_h.transform_keys
lines["syllables"].sort.to_h.transform_keys.each {|k| k.to_s.to_sym }
lines["syllables"].sort.to_h.transform_keys.each {|k| k.to_sym }
lines["syllables"][:1]
lines["syllables"][:"1"]
lines["syllables"]["1"]
lines["syllables"].sort.to_h.transform_keys.each {|k| k.to_s.to_sym }
lines["syllables"]["1"].group
lines["syllables"]["1"].group_by
aa = ["one", "two", "three"]
bb = ["one"]
aa - bb
cc = (aa - bb)
bb = ["one", "two"]
cc = (aa - bb)
animals = ['cats','dogs','fish']
mammals = ['cats','elephants']
animals & mammals
animals = ['cats','dogs','fish']
mammals = ['cats','elephants']
mammals = ['cats','elephants', 'cats']
animals & mammals
mammals.scan(/cats/)
mammals.to_s.scan(/cats/)
mammals.to_s.scan(/cats/).count
animals & mammals
["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blue", "blueviolet", "bright-cyan", "brown blue gray", "brown", "burlywood", "cadetblue", "cherry", "cherry-red", "cornflowerblue", "cream", "cream-white", "creamy-white", "crimson", "cyan", "damask rose", "dark gold", "dark-blue", "dark-brown", "dark-violet", "darkblue", "darkcyan", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "emerald", "fawn", "firebrick", "floralwhite", "forestgreen", "fuchsia", "fulvous", "gainsboro", "ghostwhite", "gold", "golden-brown", "golden-yellow", "goldenrod", "gray", "green", "greenyellow", "hotpink", "indianred", "indigo", "ivory", "khaki", "lawngreen", "lemonchiffon", "light blue", "light brown", "light-brown", "light-cyan", "light-lilac", "light-orange", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lilac", "lime", "lime-yellow", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise"]
aa = ["lightcyan", "linen"]
bb = ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blue", "blueviolet", "bright-cyan", "brown blue gray", "brown", "burlywood", "cadetblue", "cherry", "cherry-red", "cornflowerblue", "cream", "cream-white", "creamy-white", "crimson", "cyan", "damask rose", "dark gold", "dark-blue", "dark-brown", "dark-violet", "darkblue", "darkcyan", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "emerald", "fawn", "firebrick", "floralwhite", "forestgreen", "fuchsia", "fulvous", "gainsboro", "ghostwhite", "gold", "golden-brown", "golden-yellow", "goldenrod", "gray", "green", "greenyellow", "hotpink", "indianred", "indigo", "ivory", "khaki", "lawngreen", "lemonchiffon", "light blue", "light brown", "light-brown", "light-cyan", "light-lilac", "light-orange", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lilac", "lime", "lime-yellow", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise"]
aa & bb
quit
show-models
quit
show-models
Singer.al
Singer.all
Crime.all
quit
Crime.all
quit
show-models
quit
@
c
@
load_models
quit
@
load_my_models
Rails.application.eager_load!
PryRails.application.eager_load!
quit
2
@
load_my_models
load_my_models.class
unless load_my_models == ActionMailbox::InboundEmail::Incineratable
load_my_models
end
Rails.application.eager_load!
aa = Rails.application.eager_load!
aa
rc
quit
rc
show-models
quit
l
quit
 Rails.application.eager_load!
ApplicationRecord.descendants.collect { |type| type.name }
@
quit
Actor.all
actor.pluck([id,word])
actor.pluck([id])
actor.pluck([:id])
actor.pluck(:id)
Actor.pluck([:id])
actor.pluck([id])
Actor.pluck([id])
Actor.all.pluck([id])
Actor.all.pluck([:id])
Actor.all.pluck(id)
Actor.all.pluck(:id)
Actor.all.pluck(:id,:word)
Actor.all.pluck(:word)
Actor.all.pluck(:word)@
@
quit
@
words_array = dataset.constantize.pluck(:word)
@
lines["lines_count"]
lines
@
words_array = dataset.constantize.pluck(:word)
@
data["lyrics"]
data["lyrics"].join("\n")
data["lyrics"].join("\n").split(" ")
words = data["lyrics"].join("\n").split(" ")
@
words & words_array
c
words & words_array
word & words_array
ls
@
words = data["lyrics"].join("\n").split(" ")
@
words & words_array
words_array
quit
@
lyric_words & data_words
c
lyric_words & data_words
c
lyric_words & data_words
c
lyric_words & data_words
data_words
@
dataset
ls
sentiment_hash
@
lyric_words = data["lyrics"].join("\n").split(" ")
@
c
found_words
@
data_words
@
c
words_found
words_found.count
c
sentiment_hash
found_words
word
words_found
data_words.to_s
data_words.to_s.scan(/echos/)
data_words.to_s.scan(/ring/)
data_words.to_s.scan(/ring/).count
c
sentiment_hash
c
sentiment_hash
c
cc
c
cc
c
cc
c
sentiment_hash
c
cc
c
cc
c
sentiment_hash
c
cc
c
cc
sentiment_hash
c
"Blacklist"
"Blacklist".match(/Blacklist/)
"Blacklist".match(/"Blacklist"/)
"Blacklist".match(/Blacklist/)
(/Blacklist/).match("Blacklist")
(/Blacklist/).match('Blacklist')
/Blacklist/.match('Blacklist')
/Blacklist/.match('Blacklist').count
/Blacklist/.match('Blacklist')
('Blacklist').match("Blacklist")
(/Blacklist/).match("Blacklist")
(/Blacklist/).match("Blacklist")quit
Actor.all
aa = "one frigging long string with lots of words everwhere. did you say one. yes i did one."
aa.scan(/one/)
aa.scan(/one string/)
aa.scan(/long string/)
found_term
lyric_words.to_s
word
lyric_words.push("50 cent")
lyric_words.to_s
@
found_term = lyric_words.to_s.scan(/#{word}/)
found_term.count > 0
sentiment_hash[dataset][word] = found_term.count
sentiment_hash[dataset][word]
sentiment_hash[dataset]
sentiment_hash
Actor.all.find_by(name: :"william shatner")
Actor.all.find_by(word: :"william shatner")
aa = ["a", "long", "sentence"]
aa[1..3]
aa[0..2]
aa[0..2].join
aa[0..2].join(" ")
quit
found_term
@
word.count
word.class
word.split(" ")
word.split(" ").count
found_term
word
c
word
c
word
c
cc
Actor.find_by(name: :"william shatner")
Actor.find_by(word: :"william shatner")
Actor.find_by(word: :"william shatner").pluck(word)
Actor.find_by(word: :"william shatner").pluck(:word)
Actor.find_by(word: :"william shatner").pluck([:word])
Actor.find_by(word: :"william shatner").pluck([word])
Actor.find_by(word: :"william shatner"))
Actor.find_by(word: :"william shatner")
quit
c
found_term = lyric_words.to_s.scan(/tom hanks/)
lyric_words
quit
c
quit
data
File.join(root + "/lyrics", file_with_ext)
file_name_json = File.basename(file_with_ext, ".txt")
Lyrics.all
Lyric.all
a
quit
Category.all
Category.create(name: :music)
quit
a
a.update(reading_ease: readability_score.round(4), grade_level: grade_level_score.round(4))
a
Lyric.all
quit
Lyric.all
uit
quit
Lyric.all
quit
Lyric.all
quit
Lyric.all
Lyric.find(1).update(lyric_lines: ["this is a line", "2"])
Lyric.all
Lyric.find(1).update(lyric_lines: "a string")
Lyric.all
qit
quit
Lyric.all
quit
aa = {}
aa["test"] = 0
aa
aa["test"]
aa["test"] = []
aa
aa["test"]
quit
Lyric.all
Lyric.find(1).update(lyric_lines: ["this is a line", "2"])
Lyric.all
quit
Lyric.find(1).update(lyric_lines: {"lyrics":["this is a line"]})
Lyric.find(1).update(lyric_lines: ["this is a line", "2"])
Lyric.all
quit
@
lines["syllables"]
lines["percentages"]
Lyric.all
quit
Lyric.all
quit
Lyric.first
Lyric.first.pictures
quit
imageble
imageable
imageable.all
Picture.all
show-model
show-models
Lyric.first.pictures(name: :"https://www.awn.com/sites/default/files/styles/original/public/image/attached/1015740-014.jpg?itok=gUfMtFPF")
Lyric.first.pictures.find_or_create_by(name: :"https://www.awn.com/sites/default/files/styles/original/public/image/attached/1015740-014.jpg?itok=gUfMtFPF")
quit
Lyric.first.pictures.find_or_create_by(name: :"https://thatgrapejuice.net/wp-content/uploads/2015/06/katy-perry-dark-horse-billion-thatgrapejuice.jpg")
wq
quit
Lyric.find_br(name: "battlefiled")
Lyric.find_by(name: "battlefiled")
Lyric.find_by(title: "battlefiled")
Lyric.find_by(title: "battlefield")
Lyric.find_by(title: "battlefield").pictures.first
Lyric.find_by(title: "battlefield").pictures.find_or_create_by(name: :"https://images.genius.com/8c0f3634e3bb1eaf3bb9ede5705720c7.1000x1000x1.jpg")
Lyric.find_by(title: "champaigne")
Lyric.find_by(title: "champaigne problems")
Lyric.find_by(title: "champaigne_problems")
Lyric.find_by(title: "champagne_problems")
Lyric.find_by(title: "champagneproblems")
Lyric.find_by(title: "champagne problems")
Lyric.all
Lyric.all.pluck(:title)
Lyric.find_by(title: "champaigne-problems").pictures.find_or_create_by(name: :"https://pbs.twimg.com/media/Eo_NfeFXYAMu1Cp.jpg")
Lyric.find_by(title: "evermore").pictures.find_or_create_by(name: :"https://assets.teenvogue.com/photos/5fd50da95521eee9e3546333/16:9/w_2560%2Cc_limit/BackCoverSquare_No%2520Text.jpg)
Lyric.find_by(title: "evermore").pictures
Lyric.find_by(title: "evermore")
Lyric.find_by(title: :"evermore")
Lyric.find_by(title: :"evermore").pictures.find_or_create_by(name: :"https://assets.teenvogue.com/photos/5fd50da95521eee9e3546333/16:9/w_2560%2Cc_limit/BackCoverSquare_No%2520Text.jpg)
Lyric.find_by(title: :"evermore")
!
Lyric.find_by(title: :"evermore")
Lyric.find_by(title: :"evermore").pictures.find_or_create_by(name: :"https://assets.teenvogue.com/photos/5fd50da95521eee9e3546333/16:9/w_2560%2Cc_limit/BackCoverSquare_No%2520Text.jpg)
Lyric.find_by(title: :"evermore")
!
Lyric.find_by(title: :"evermore")
Lyric.find_by(title: :"evermore").pictures
Lyric.find_by(title: :"evermore").pictures.find_or_create_by(name: :"https://pyxis.nymag.com/v1/imgs/127/421/17643dcd79ee3d4bedfdaed62b7c8619df-taylor-swift-evermore.2x.rsocial.w600.jpg")
Lyric.find_by(title: :"hotshit").pictures.find_or_create_by(name: :"http://kotilyrics.com/wp-content/uploads/2022/07/Cardi-B-x-Kanye-West-Lil-Durk-%E2%80%93-Hot-Shit-Audio-Lyrics.jpg")
Lyric.find_by(title: :"hot-shit").pictures.find_or_create_by(name: :"http://kotilyrics.com/wp-content/uploads/2022/07/Cardi-B-x-Kanye-West-Lil-Durk-%E2%80%93-Hot-Shit-Audio-Lyrics.jpg")
quit
Lyric.all.pluck(:title)
Lyric.find_by(title: :"nothing-breaks-like-a-hart").pictures.find_or_create_by(name: :"https://hips.hearstapps.com/hmg-prod/images/miley-cyrus-nothing-breaks-like-a-heart-1543596695.jpg")
Lyric.all.pluck(:title)
Lyric.find_by(title: :"wrecking-ball").pictures.find_or_create_by(name: :"https://media.glamour.com/photos/5f4c44e20c71c58fc210d35f/master/pass/mgid_ao_image_mtv.jpg")
quit
lines = nested_hash
cd nested_hash
ls
cd
@
c
cwords_array
words_array
c
quit
Lyric.all.pluck(:title)
Lyric.all.find_by(name: :"better-in-time")
Lyric.all.find_by(word: :"better-in-time")
showm-models
show-models
Lyric.all.find_by(title: :"better-in-time")
word_syllable_count = syllable_count(word)
word
lines["syllables"][word_syllable_count] += 1
lines["syllables"]
lines["syllables"][word_syllable_count] += 1
lines["syllables"]
lines
lines["syllables"]
c
lines
c
lines
t
aa = t.now
aa = Time.now
aa - t
t
aa
@
syllable_count_word
lines["syllables"][syllable_count_word] += 1
lines
c
lines
@
lines
c
cc
c
lines
date
data
lines
c
syllable_word_count
word
lines
lines["longest_syllable"] = 0
lines
lines["lines_count"] = data["lyrics"].count
lines
lines["words_count"] = data["lyrics"].join(" ").split.count
lines
c
lines
words_array = line.split
words_per_line << words_array.count
c
lines
c
word
c
word
syllable_word_count
lines
c
lines
cd Array
ls
cd
cd Hash
ls
quit
data["lyrics"]
data["lyrics"].join(" ")
data["lyrics"].join(" ").class
data["lyrics"].join(" ").class.spit
data["lyrics"].join(" ").split
Lyric.find_by(title: :"better-in-time").pictures.find_or_create_by(name: :"https://i.ytimg.com/vi/Vzo-EL_62fQ/maxresdefault.jpg")
lyric.find_by(title: :"in-the-air-tonight")
Lyric.all.find_by(title: :"in-the-air-tonight")
quit
Lyric.all.find_by(title: :"in-the-air-tonight").delete
Lyric.all.find_by(title: :"in-the-air-tonight")
quit
Lyric.all.find_by(title: :"in-the-air-tonight")
Lyric.all.find_by(title: :"in-the-air-tonight").delete
quit
@
words_array
words_array.count
words_per_line
c
@
syllable_word_count
word
lines
c
lines
quit
c
lines
Lyric.all.find_by(title: :"in-the-air-tonight").delete
quit
lines
quit
words_per_line
c
Lyric.all.find_by(title: :"in-the-air-tonight")
cd Hash
ls
lines
quit
lines
cd Hash
ls
cd
lines.deep_symbolize_keys
lines
@
per["words_count"]
c
per
c
lines[:syllables].each { |k, v| lines[:percentages][k] = (v / per[:words_count].to_f) * 100 }
avg_sentence_length = (lines[:words_count].to_f / lines[:lines_count].to_f)
lines[:percentages].count
c
lines
Lyric.all.find_by(title: :"in-the-air-tonight")
Lyric.all.find_by(title: :"in-the-air-tonight").delete
quit
c
Lyric.all.find_by(title: :"in-the-air-tonight")
Lyric.all.find_by(title: :"in-the-air-tonight").delete
quit
Lyric.all.find_by(title: :"in-the-air-tonight")
Lyric.all.find_by(title: :"in-the-air-tonight").delete
Lyric.all.find_by(title: :"in-the-air-tonight")
quit
lines[:longest_syllable]
lines
lines[:longest_syllable]
syllable_word_count
lines[:longest_syllable].class
Lyric.all.find_by(title: :"in-the-air-tonight")
cheat
HT 100
Lyric.find_by(title: :"better-in-time").pictures.find_or_create_by(name: :"https://images.genius.com/e8ebf336ace3c27ee6813e1332a05f3b.1000x1000x1.jpg")
quit
Lyric.find_by(title: :"in-the-air-tonight").pictures.find_or_create_by(name: :"https://images.genius.com/e8ebf336ace3c27ee6813e1332a05f3b.1000x1000x1.jpg")
Lyric.find_by(title: :"better-in-time").pictures
Lyric.find_by(title: :"better-in-time").pictures.last.delete
quit
Lyric.find_by(title: :"in-the-air-tonight")
quit
lines
quit
Lyrics.all.map {|a| a.delete }
Lyric.all.map {|a| a.delete }
Lyric.all.count
quit
Pictures.all
Picture.all
Lyric.all.first
Lyric.all.first.pluck(:id)
Picture.first
Picture.first.update(imageable_id: 16)
Picture.first
Picture.find(3)
Picture.find(3).update(imageable_id: 16)
Picture.find(3)
Lyric.all.find(16)
Lyric.all.find(16).pictures
Lyric.all.find(16).pictures.first.delete
W
quit
Lyric.all.find(17)
Picture.all.pluck([:title])
Picture.all.pluck(:title)
Picture.all.pluck(:title,:id)
Picture.first
Picture.all.pluck(:name,:id)
Picture.all.find(9)
Picture.all.find(9).update(imageable_id: 17)
Picture.all.find(5)
Lyric.all.find(18)
Picture.all.find(5).update(imageable_id: 18)
Picture.all.find(6)
Picture.all.find(7)
Picture.all.find(1)
Picture.all.find(2)
Picture.all.find(2).update(imageable_id: 18)
Picture.all.find(2).update(imageable_id: 19)
quit
ApplicationRecord.descendants
@
cheat
wtf?
edit load_my_models
@
ApplicationRecord.descendants.collect { |type| type.name }
edit load_my_models
lines
lines[:syllables]
lines[:syllables]..sort_by(&:last)
lines[:syllables].sort_by(&:last)
lines[:syllables].sort_by(&:last).to_h
lines[:syllables].sort_by(&:first).to_h
lines[:syllables].sort_by{|k,v| k}.to_h
lines[:syllables].sort_by{|k,v| k}
lines[:syllables[.class
lines[:syllables].class
lines[:syllables]
lines[:syllables].sort_by{|k,v| k}.reverse
lines[:syllables].sort_by{|k,v| k}.reverse.to_h
lines[:syllables].sort_by(&:last).to_h
lines[:syllables].sort_by(&:first).to_h
person_list.store("daniel")
person_list.store("steve")
person_list.store("stephen")
person_list.store("danaka")
person_list.store("dante")
person_list.store("david")
person_list.store("tom")
ls
person_list
person_list.compact
@
HT 10000
HR 1621..1623
base
scale
base * scale ** 1
base = 16
base * scale ** 1
base * scale ** 2
base * scale ** 3
Lyrics.all
aa = "but now the day bleeds in to night fall bleeds"
aa.scan(/bleeds/)
lyrics = "but now the day bleeds in to night fall bleeds"
lyrics
lyrics.scan(/bleeds/)
uit
quit
lines
c
lines
@
c
sentiment_hash
aa = ["one", "two", "three"]
bb = ["one", "one", "two"]
aa & bb
Lyrics.all.map {|a| a.destroy }
Lyrics.all.map {|a| a.delete }
Lyric.all.map {|a| a.delete }
quit
c
dataset
dataset.class
dataset.constantize.class
dataset.constantize.pluck(:word)
Actor.all.pluck(:name)
Actor.all.pluck(:title)
Actor.all
Actor.all.pluck(:word)
c
ls
sentiment_hash
c
sentiment_hash
c
k
v
c
@
/#{data[:lyrics]}/.match(/#{k}\{#{k.length}\}/)
/#{data[:lyrics].to_s}/.match(/#{k}\{#{k.length}\}/)
data[:lyrics].to_s
/#{data[:lyrics].to_s}/.match(/#{k}/)
/#{data[:lyrics].to_s}/.match(/this/)
/#{data[:lyrics].to_s}/.match("/this/")
/#{data[:lyrics].to_s}/.match("#{k}")
k
/#{data[:lyrics].to_s}/.match("#{k}{4}")
/#{data[:lyrics].to_s}/.match("#{k}{2}")
/#{data[:lyrics].to_s}/.scan("#{k}")
data[:lyrics].to_s.scan("#{k}")
data[:lyrics].to_s.scan("#{k}{3}")
data[:lyrics].to_s.scan(/#{k}{3}/)
data[:lyrics].to_s.scan(/#{k}{4}/)
data[:lyrics].to_s.scan(/\v#{k}{4}/)
data[:lyrics].to_s.scan(/#{k}{4}/)
data[:lyrics].to_s.scan(/#{k}/)
data[:lyrics].to_s.scan(/#{k}.*/)
data[:lyrics].to_s.scan(/#{k}.*\s/)
data[:lyrics].to_s.scan(/#{k}/)
data[:lyrics] << beening
data[:lyrics] << 'beening"
data[:lyrics] << "beens"
data[:lyrics].to_s
!
data[:lyrics].to_s
data[:lyrics].to_s.scan(/#{k}/)
data[:lyrics].to_s.scan(/#{k}s/)
data[:lyrics].to_s.scan(/#{k}+ "s"/)
data[:lyrics]
data[:lyrics] << "think"
data[:lyrics] << "thinking"
data[:lyrics] << "thinks"
2
@
data[:lyrics].to_s.scan(/think/)
data[:lyrics].to_s.scan(/think.*\s/)
data[:lyrics].to_s.scan(/think.*/)
data[:lyrics].to_s.scan(/\w{4}([^\s]+)/)
data[:lyrics].to_s.scan(/think{5}([^\s]+)/)
data[:lyrics].to_s.scan(/think([^\s]+)/)
data[:lyrics].to_s.scan(/think([^\s]+)/).compact
data[:lyrics].to_s.scan(/think([^\s]+)/).to_h
data[:lyrics].to_s.scan(/think([^\s]+)/)
data[:lyrics].to_s
data[:lyrics].to_s.scan(/think([^\s]+)/)
data[:lyrics].to_s.scan(/think([^\s]+)/).flatten
data[:lyrics].to_s.scan(/think([^\s]+)/).flatten.count
data[:lyrics].to_s.scan(/think([^\s]+)/).flatten.compact
c
@
result_a
c
result_a
c
result_a
c
result_a
k
data[:lyrics]
c
result_a
k
k.shift
cd String
ls
k.ord
k[1..-1]
cd
k.ord
k[1..-1]
k
@
result_a = data[:lyrics].to_s.scan(/#(?="{k[1..-1]}")([^\s]+)/).flatten.compact
c
result_a = data[:lyrics].to_s.scan(/#(?="{k[1..-1]}")([^\s]+)/).flatten.compact
c
result_a = data[:lyrics].to_s.scan(/#(?="{k[1..-1]}")([^\s]+)/).flatten.compact
c
result_a = data[:lyrics].to_s.scan(/#(?="{k[1..-1]}")([^\s]+)/).flatten.compact
c
result_a = data[:lyrics].to_s.scan(/#(?="{k[1..-1]}")([^\s]+)/).flatten.compact
result_a = data[:lyrics].to_s.scan(/(?={k[1..-1]})([^\s]+)/).flatten.compact
result_a = data[:lyrics].to_s.scan(/(?=#{k[1..-1]})([^\s]+)/).flatten.compact
k
c
result_a = data[:lyrics].to_s.scan(/(?=#{k[1..-1]})([^\s]+)/).flatten.compact
result_a = data[:lyrics].to_s.scan(/#{k[0]}(?=#{k[1..-1]})([^\s]+)/).flatten.compact
k
c
result_a = data[:lyrics].to_s.scan(/#{k[0]}(?=#{k[1..-1]})([^\s]+)/).flatten.compact
k
c
result_a = data[:lyrics].to_s.scan(/#{k[0]}(?=#{k[1..-1]})([^\s]+)/).flatten.compact
c
result_a = data[:lyrics].to_s.scan(/#{k[0]}(?=#{k[1..-1]})([^\s]+)/).flatten.compact
k
result_a = data[:lyrics].to_s.scan(/#{k}(?=#{k[1..-1]})([^\s]+)/).flatten.compact
result_a = data[:lyrics].to_s.scan(/#{k}([^\s]+)/).flatten.compact
k
result_a = data[:lyrics].to_s.scan(/\A#{k}([^\s]+)/).flatten.compact
c
result_a = data[:lyrics].to_s.scan(/\A#{k}([^\s]+)/).flatten.compact
c
result_a = data[:lyrics].to_s.scan(/\A#{k}([^\s]+)/).flatten.compact
c
result_a = data[:lyrics].to_s.scan(/\A#{k}([^\s]+)/).flatten.compact
c
result_a = data[:lyrics].to_s.scan(/\A#{k}([^\s]+)/).flatten.compact
c
result_a = data[:lyrics].to_s.scan(/\A#{k}([^\s]+)/).flatten.compact
c
puts result_a
puts result_a.class
quiut
quit
c
@
Rails.application
@
Rails.application.eager_load!
ApplicationRecord.descendants
c
dataset_words = dataset.constantize.pluck(:word)
dataset_words.class
logger.class
c
@
remove_unwanted_models.each { |m| cached_models.delete(m) if cached_models.include?(m) }
cached_models
Lyric.last
Lyric.find(32)
Lyric.find(32).map {|a| a.delete }
Lyric.all.find(32).map {|a| a.delete }
Lyric.all.find_by(name: :"american-pie").map {|a| a.delete }
Lyric.all.find_by(title: :"american-pie").map {|a| a.delete }
Lyric.all.map {|a| a.delete }
quit
c
lyric_options
HT
HT 100
lyric_file
lyric_file.split(/\//)[-2]
quit
Actor.all
quit
Actor.all
quit
Artist.all
quit
Album.all
Artist.first
Artist.first.albums
l
quit
Artist.first.albums
Artist.first.albums.first.songs
Artist.first.albums.first
Artist.first.albums
Artist.first.albums.first.songs
Artist.all.map {|a| a.delete }
Song.all.map {|a| a.delete }
uit
quit
Artist.first.albums.first.songs
Artist.first
Artist.first.albums.first
Artist.first.albums.first.songs
quit
Artist.all.pluck(:name)
root
file_with_ext
File.basename(file_with_ext, ".txt")
File.join(root + "lyrics", File.basename(file_with_ext, ".txt"))
@
[200~file_name_json = File.join(root + "lyrics", data[:artist])~
file_name_json = File.join(root + "lyrics", data[:artist])
File.open(file_name_json + ".json", "w") { |f| f.write(JSON.pretty_generate(data)) }
ls
l
tree
cd lyrics
c
Artist.all.pluck(:name)
aa = ['think', 'thinking', 'thinks']
bb = ['think']
aa & bb
aa.scan(/think/)
aa.to_s.scan(/think/)
quit
aa = ['think', 'thinking', 'thinks']
bb = ['think']
/aa.to_s/.match(/think[es|ing|ed]([^\s]+)/)
/aa.to_s/.match("/think[es|ing|ed]([^\s]+)/")
aa.to_s.scan("/think[es|ing|ed]([^\s]+)/")
aa.to_s.scan(/think[es|ing|ed]([^\s]+)/)
aa.to_s.scan(/think[es|ing|ed|s]([^\s]+)/)
aa.to_s
aa.to_s.regex(/think[es|ing|ed|s]([^\s]+)/)
aa.to_s.match(/think[es|ing|ed|s]([^\s]+)/)
"think thinks thinking".regex(/think[es|ing|ed|s]([^\s]+)/)
"think thinks thinking".scan(/think[es|ing|ed|s]([^\s]+)/)
"think thinks thinking".scan(/think/)
"think thinks thinking".match(/think/)
/"think thinks thinking"/.match("think")
l
"think thinks thinking".scan(/think[es|ing|ed|s]([^\s]+)/)
"think thinks thinking".scan(/\Vthink[es|ing|ed|s]([^\s]+)/)
"think thinks thinking".scan(/\vthink[es|ing|ed|s]([^\s]+)/)
"think thinks thinking".scan("think[es|ing|ed|s]([^\s]+)")
"Thinking"
cd String
ls
qiut
Picture.all
quit
Artist.last
Artist.last.pictures
Artist.all
quit
Artist.all
quit
Artist.find_by(name: "don mclean")
Artist.find_by(name: "don-mclean")
Artist.find_by(name: "don-mclean").albums
qit
quit
Album.first
song.first
Song.first
Song.(album_id: 1)
Song.find_by(album_id: 1)
quit
@
params
param
ls
params._to_h
params[:id]
ls
c
Song.find(5)
quit
@
params
ls
@_parameter_encodings
@parent_name
@
c
Song.first
Artist.first
Artist.first.pictures
Artist.first.pictures.find_or_create_by(name: :"https://images8.alphacoders.com/598/598821.jpg")
Artist.find(2)
Artist.find(1)
Artist.find(2)
Artist.find(2).pictures
Artist.find(2).pictures.find_or_create_by(name: :"https://media.gq.com/photos/5ac50c1471ef6514cccc2a48/1:1/w_2667,h_2667,c_limit/Cardi-B%E2%80%99s-Money-Moves-GQ-May-040918-03.jpg")
quit
c
Artist.find(3).pictures
Artist.find(3)
Artist.find(3).pictures.find_or_create_by(name: :"https://i.guim.co.uk/img/media/c8b67a4d7e15e2e5f0746cbd2024dc18a3023169/0_17_3000_1902/master/3000.jpg?width=1020&quality=85&fit=max&s=ef6c55c59f66d0360c9853737f591153")
Artist.find(4)
Artist.find(4).pictures.find_or_create_by(name: :"https://media.vanityfair.com/photos/55b6a35a9e9755183d97a183/master/pass/katy-perry-presidency.jpg")
Artist.find(5)
Artist.find(5).pictures.find_or_create_by(name: :"https://vz.cnwimg.com/wp-content/uploads/2009/10/leona-lewis.png")
Artist.find(3)
Artist.find(3).albums.first
Artist.find(3).albums.first.pictures
Artist.find(3).albums.first.pictures.find_or_create_by(name: :"https://www.gottahaverockandroll.com/ItemImages/000013/mar14-345_lg.jpeg")
Artists.all
Artist.all
Artist.all.last
Artist.all.last.albums
Artist.all.last.albums.first.songs
quit
Artist.all.last
Artist.all.last.picture.find_or_create_by(name: :"http://progwatch.com/wp-content/uploads/2020/05/phil-collins-drums.jpg")
Artist.all.last.pictures.find_or_create_by(name: :"http://progwatch.com/wp-content/uploads/2020/05/phil-collins-drums.jpg")
;quit
quit
Artist.find(5)
Artist.find(6)
Artist.find(6).pictures.find_or_create_by(name: :"https://images3.alphacoders.com/971/971272.jpg")
Artist.find(7)
Artist.find(7).pictures.find_or_create_by(name: :"https://i.ytimg.com/vi/HiY3wif9ZPg/maxresdefault.jpg")
Artist.find(8)
Artist.find(8).pictures.find_or_create_by(name: :"https://wallpapercave.com/wp/wp7261632.jpg")
Artist.find(5)
Artist.find(5).pictures.find_or_create_by(name: :"https://i.ytimg.com/vi/umKEAPX75J8/maxresdefault.jpg")
Artist.find(5).pictures.laste.delete
Artist.find(5).pictures.last.delete
Artist.find(5)albums.first
Artist.find(5).albums.first
Artist.find(5).albums.first.pictures.find_or_create(name: :"https://i.ytimg.com/vi/umKEAPX75J8/maxresdefault.jpg")
Artist.find(5).albums.first.pictures.find_or_create_by(name: :"https://i.ytimg.com/vi/umKEAPX75J8/maxresdefault.jpg")
Artist.find(6)
Artist.find(7)
Artist.find(8)
Artist.find(8).albums.first.pictures(name: :"https://nypost.com/wp-content/uploads/sites/2/2020/12/taylor-swift-evermore-1-1.jpg?quality=75&strip=all")
Artist.find(8).albums.first.pictures.find_or_create_by(name: :"https://nypost.com/wp-content/uploads/sites/2/2020/12/taylor-swift-evermore-1-1.jpg?quality=75&strip=all")
Artist.find(4).albums.first.pictures.find_or_create_by(name: :"https://i.imgur.com/5fSNQE3.jpg")
Artist.find(4).albums.first.pictures.first.delete
Artist.find(4).albums.first.pictures.first
Artist.find(4).albums.first.pictures
Artist.find(4).albums.first.pictures.find_or_create_by(name: :"https://i.discogs.com/nUn7uofKLzM5xJjL_0wXdK5Un1vkruk_WkvyNKv_-PY/rs:fit/g:sm/q:90/h:583/w:600/czM6Ly9kaXNjb2dz/LWRhdGFiYXNlLWlt/YWdlcy9SLTUxOTAw/NTUtMTY0Njk0MDU2/MC0xMDkxLmpwZWc.jpeg")
Artist.find(9).albums.first.pictures.find_or_create_by(name: :"https://i.scdn.co/image/ab67616d0000b273f6954c1f074f66907a8c5483")
Artist.find(1).albums.first.pictures.find_or_create_by(name: :"https://cdn.hmv.com/r/w-1280/p-webp/hmv/files/40/40efe4ef-6e35-4d8f-b2c5-0610653ff612.jpg")
Artist.find(6).albums.first.pictures.find_or_create_by(name: :"https://i.pinimg.com/originals/16/8c/d5/168cd531888ffffdb3acc25070b91e26.jpg")
Artist.find(6).albums.last.pictures.find_or_create_by(name: :"https://i.pinimg.com/564x/4b/8e/d9/4b8ed9b1d7f2b30aabb0c8dbe0892171.jpg")
Artist.find(7).albums.first.pictures.find_or_create_by(name: :"https://lastfm.freetls.fastly.net/i/u/ar0/6d6bfcec42da3ed19e56259f4d089ed0.jpg")
Artist.find(2).albums.first.pictures.find_or_create_by(name: :"https://media.pitchfork.com/photos/62be721072c7d72fed5e767b/3:2/w_2250,h_1500,c_limit/cardi-b-hot-shit.jpg"
Artist.find(2).albums.first.pictures.find_or_create_by(name: :"https://media.pitchfork.com/photos/62be721072c7d72fed5e767b/3:2/w_2250,h_1500,c_limit/cardi-b-hot-shit.jpg")
!
Artist.find(2).albums.first.pictures.find_or_create_by(name: :"https://media.pitchfork.com/photos/62be721072c7d72fed5e767b/3:2/w_2250,h_1500,c_limit/cardi-b-hot-shit.jpg")
quit
Artist.all
Artist.find(3)
Artist.find(3).delete
Album.all
Album.all.find_by(artist_id: 3)
Album.all.find_by(artist_id: 3).delete
Album.all.find_by(artist_id: 3).songs.delete
Album.all.find_by(artist_id: 3).songs
Album.all.find_by(artist_id: 3).songs.delete
Album.all.find_by(artist_id: 3).songs
Album.all.find_by(artist_id: 3).songs.map {|a| a.delete }
Album.all.find_by(artist_id: 3).songs
Album.all.find_by(artist_id: 3).map {|a| a.delete }
Album.all.find_by(artist_id: 3).delete
Album.all.find_by(artist_id: 3)
artist.find(3)
Artist.find(3)
Artist.find(3).delete
Artist.find(3)
quit
Color.all
AnalogousColor.all
quit
show-models
quit
show-models
quit
show-models
vulgar.all
Vulgar.all
quit
root
quit
root = "#{home}/Code/Ruby/Projects/#{app_name}/lib/data"
quit
root = "#{home}/Code/Ruby/Projects/#{app_name}/lib/data"
Rails.application.class.parent.to_s.underscore
Rails.application.class
Rails.application.class.to_s
cd Rails.application.class
ls
find_root
cd
Rails.application.class.parent.name
Rails.application.class
::Rails.application.class.parent.name
::Rails.application.class
::Rails.application
cdRails.application.class.parent
cd Rails.application.class.parent
l
@
cd Rails.application.class.parent
cd Rails.application.parent
cd Rails.application.parent.name
cd Rails.application.parent
ls
app_name
cd
Rails.application.class.module_parent
c
@
data_hash
c
file
@
data_hash
@
c
k
data_hash
k
data_hash["label"]
k == data_hash.key("label")
k
data_hash.key("label")
data_hash.key?("label")
data_hash
data_hash.key?("Label")
Artist.al
Artist.all
Boxer.all
show-models
quit
k
data_hash.key?("Label")
k == data_hash.key?("Label")
k
/#{k}/.match(data_hash.key?("Label"))
/#{k}/.match("data_hash.key?("Label")")
/#{k}/.match("#{data_hash.key?("Label")}")
k == data_hash.key?("Label")
k =~ data_hash.key?("Label")
data_hash.key?("Label")
k
data_hash.key?("Label").class
data_hash.key?("Label") == "true"
data_hash.key?("Label")
data_hash.key?("Label") == true
@
data_hash.key?("Label") == true
k == "Label"
c
quit
Artist.all
Boxer.all
quit
Picture.all
quit
Artist.all
quit
@
ls
dataset_words
dataset.constantize.pluck(:word)
dataset.constantize.pluck(:word, :label)
dataset.constantize.pluck(:word, :label).to_h
dataset.constantize.pluck(:word, :label)
aa = dataset.constantize.pluck(:word, :label)
aa
aa.[0]
aa[0]
aa[0][0]
aa.group
@
dataset.constantize.first
dataset.constantize.first.pluck(:label)
dataset.constantize.first[:label]
 label = dataset.constantize.first[:label]
label
c
label
dataset.constantize.first[:label]
dataset.constantize.first
dataset.constantize
root
c
cached_models
AnalogousColor.all
ActiveRecord
!
ActiveRecord
ls
show-models
quit
show-models
quit
show-models
quit
show-models
quit
show-models
quit
show-models
rc
show-models
quit
show-models
quit
l
rc
show-model
show-models
quit
remove_unwanted_models.each { |m| cached_models.delete(m) if cached_models.include?(m) }
cached_models
@
c
@
dataset.constantize
dataset.constantize.first[:label]
dataset
ls
c
dataset.constantize.first
dataset.constantize
dataset.constantize.first
cached_models
lines
sentiment_hash
Song.first
Song.all
Artist.all
quit
Song.all
quit
scale = 1.250
base = 16
scale * base**1
scale * base**2
scale * base **2
base * scale**1
base * scale**2
base * scale**3
base * scale**4
Dj.all
quit
hash_results = data.merge(sentiment_hash)
c
Aong.all
Song.all
quit
Song.all
a_a_s.title
a_a_s
c
a_a_s.class
a_a_s
a_a_s.to_h
cd Song
ls
cd
@
a_a_s
a_a_s..attributes
a_a_s.attributes
a_a_s.attributes.class
a_a_s.as_json
c
Actor.all
quit
directory "data", "lib/data"
copy_directory "data", "lib/data"
directory "music.rake", "lib/tasks/music.rake"
app_name = Rails.application.class.module_parent.to_s
root = "#{app_name}/lib/data"
lyrics_directory(root)
k
k.class
k.constantize.count
v.count
k
v
v.value
v.count
@
data_hash.key?("Label")
data_hash.keys
k.constantize.class
Blacklist.all.count
Blacklist.all
@
k
v
c
data_hash.key?("Label") == true
k == "Label"
k
c
 k.constantize.count > 0
k
k == "Label"
k.constantize.count > 0
c
k == "Label"
k.constantize.count > 0
k == "Label" || k.constantize.count > 0
k
c
k
k == "Label"
k.constantize.count > 0
c
k
c
cc
c
cc
c
cc
c
k == "Label" || k.constantize.count > 0
k == "Label" 
k
c
k == "Label" || k.constantize.count > 0
aa = ["thinking", "thinks", "think"]
aa.to_s.scan(/think([a-zA-Z]+?)(s\b|\b)/)
aa.to_s.scan(/think([a-zA-Z]+?)(s\b|\b)/).compact
aa.to_s.scan(/think([a-zA-Z]+?)(s\b|\b)/).to_h
aa.to_s.scan(/think([a-zA-Z]+?)(s\b|\b)/).to_h[]0
aa.to_s.scan(/think([a-zA-Z]+?)(s\b|\b)/).to_h[0]
bb = ["run", "runner", "running", "rune"]
aa.to_s.scan(/run([a-zA-Z]+?)(s\b|\b)/).to_h[0]
aa.to_s.scan(/run([a-zA-Z]+?)(s\b|\b)/).to_h
bb.to_s.scan(/run([a-zA-Z]+?)(s\b|\b)/).to_h
word
result = "#{word}" + "([a-zA-Z]+?)(s\b|\b)"
lines
lines.scan(/result/)
word
lines.scan(/Caleb([a-zA-Z]+?)(s\b|\b)/)
c
lines.scan(/result/)
c
lines.scan(/result/)
q
hashy
bb.to_s.scan(/run([a-zA-Z]+?)(s\b|\b)/).to_h
bb = ["run", "runner", "running", "rune"]
lines.scan(/run([a-zA-Z]+?)(s\b|\b)/)
bb.scan(/run([a-zA-Z]+?)(s\b|\b)/)
bb.to_s.scan(/run([a-zA-Z]+?)(s\b|\b)/)
bb = ["run", "runner", "running", "rune"]
bb.to_s.scan(/run([a-zA-Z]+?)(s\b|\b)/)
aa = run([a-zA-Z]+?)(s\b|\b)/
aa = "run([a-zA-Z]+?)(s\b|\b)/"
aa.class
bb.to_s.scan(/aa/)
hashy
bb = ["run", "runner", "running", "rune"]
bb.to_s.scan(/aa/)
aa = "(run)([a-zA-Z]+?)(s\b|\b)/"
aa
aa = "(run)([a-zA-Z]+?)(s\b|\b)/".to_h
bb.scan(/"(run)([a-zA-Z]+?)(s\b|\b)/")
!
bb.scan(/(run)([a-zA-Z]+?)(s\b|\b)/)
bb.to_s.scan(/(run)([a-zA-Z]+?)(s\b|\b)/)
bb.to_s.scan(/\b(run)([a-zA-Z]+?)(s\b|\b)/)
bb.to_s.scan(/\b(run)([a-zA-Z]+?)(s\b|\b)\b/)
hashy
lines
hashy
lines
lines.scan(/homeof/)
lines.scan(/home of/)
hashy
lines.scan(/ava with/)
lines.scan(/Ava with/)
@
hashy
lines.scan(/Room and/)
lines.scan(/room and/)
hashy
c
hashy
c
hashy
@
word
lines.scan(/\b(#{word})([a-zA-Z]+?)\b(?=\s)\b/)
lines.scan(/\b(#{word})([a-zA-Z]+?)\b(?=\s)\b/).to_h
lines.scan(/\b(#{word})([a-zA-Z]+?)\b(?=\s)\b/).group_by
lines.scan(/\b(#{word})([a-zA-Z]+?)\b(?=\s)\b/).group_by.to_h
lines.scan(/\b(#{word})([a-zA-Z]+?)\b(?=\s)\b/).group_by { |w| w[0].itself }
lines.scan(/\b(#{word})([a-zA-Z]+?)\b(?=\s)\b/).group_by { |w| w.shift }
lines.scan(/\b(#{word})([a-zA-Z]+?)\b(?=\s)\b/).group_by { |w| w.shift }.flatten
lines.scan(/\b(#{word})([a-zA-Z]+?)\b(?=\s)\b/).group_by { |w| w.shift }
lines.scan(/\b(#{word})([a-zA-Z]+?)\b(?=\s)\b/).group_by { |w| w.shift }.uniq
lines.scan(/\b(#{word})([a-zA-Z]+?)\b(?=\s)\b/).group_by { |w| w.shift }
an
hashy[an]
hashy["an"]
hashy[:an]
aa = lines.scan(/\b(#{word})([a-zA-Z]+?)\b(?=\s)\b/).group_by { |w| w.shift }
aa
aa.uniq
aa.class
aa["an"]
aa["an"].flatten
aa["an"].flatten.uniq
scan_result
scan_result.count
hashy
c
hashy
c
hashy
c
cd String
ls
person_list.store("damien")
person_list.store("dan")
person_list.store("steph")
person_list.store("steve")
person_list.store("steven")
person_list.store("stephan")
person_list.compact
return_hash
return_hash[word].flatten.uniq
c
return_hash
return_hash[word].flatten.uniq
return_hash
return_hash[word]
return_hash[word].class
return_hash[word].count
return_hash[word][0]
return_hash[word][2]
return_hash[word].flatten
return_hash[word] = return_hash[word].flatten
return_hash
return_hash[word] = return_hash[word].flatten.uniq
return_hash
c
return_hash
c
return_hash
return_hash[word].flatten
return_hash[word].flatten.uniq
return_hash[word] = return_hash[word].flatten.uniq
return_hash
c
return_hash
c
return_hash
c
cc
c
return_hash
return_hash.class
return_hash
@
hashy
hashy[word] = return_hash[word].flatten.uniq
hashy
c
hashy
@
return_hash
c
return_hash
c
return_hash
c
return_hash
c
return_hash
c
return_hash
c
return_hash
c
return_hash
lines.scan(/\b(#{word})([a-zA-Z]+?)\b(?=\s)\b/)
c
cd String
ls
c
cc
c
cc
c
word.strip
c
return_hash
c
return_hash
c
cc
c
return_hash
c
return_hash
c
return_hash
c
return_hash
c
return_hash
c
return_hash
hashy
c
hashy
c
hashy
return_hash
@
@return_hash[word.strip].flatten.uniq
return_hash[word.strip].flatten.uniq
c
return_hash
hashy
c
return_hash
word
word.strip
hashy
word.gsub(/\W|\d/, "")
c
word
word.gsub(/\W|\d/, "")
return_hash
hashy
return_hash
@
return_hash = lines.scan(/\b(#{word.strip})([a-zA-Z]+?)\b(?=\s)\b/).group_by { |w| w.shift }.transform_values do |values| values.flatten.uniq end
c
lines.scan(/\b(#{word.strip})([a-zA-Z]+?)\b(?=\s)\b/)
c
lines.scan(/\b(#{word.strip})([a-zA-Z]+?)\b(?=\s)\b/)
c
lines.scan(/\b(#{word.strip})([a-zA-Z]+?)\b(?=\s)\b/)
lines.scan(/\b(#{word.strip})([a-zA-Z]+?)\b(?=\s)\b/).flatten
lines.scan(/\b(#{word.strip})([a-zA-Z]+?)\b(?=\s)\b/).flatten.uniq
lines.scan(/\b(#{word.strip})([a-zA-Z]+?)\b(?=\s)\b/)
lines.scan(/\b(#{word.strip})([a-zA-Z]+?)\b(?=\s)\b/).flatten.uniq
hashy[word] = lines.scan(/\b(#{word.strip})([a-zA-Z]+?)\b(?=\s)\b/).flatten.uniq
c
w
hashy[word] = lines.scan(/\b(#{word.strip})([a-zA-Z]+?)\b(?=\s)\b/).flatten.uniq
c
hashy[word] = lines.scan(/\b(#{word.strip})([a-zA-Z]+?)\b(?=\s)\b/).flatten.uniq
hashy
c
hashy
c
cc
c
cc
hashy
aa = {a: 1, b: {c: 2}}
aa.keys?
aa.keys
cd aa
ls
cd
aa.each_key {|k| puts k }
create_scan_hash(lines, search)
c
ls
@
ls
sentiment_hash
c
last_level_key
key
value
@
k
v
v.keys
c
v
@
key == "blacklist"
key
key.downcase
c
key.downcase == "blacklist"
key.downcase
additinal_words_hash(data[:lyrics], value.keys)
additinal_words_hash(data[:lyrics].to_s, value.keys)
c
additinal_words_hash(lyric_string, v.keys?)
additinal_words_hash(lyric_string, v.keys)
c
ballbag
c
ballbag
c
ballbag
c
ballbag
c
ballbag
c
ballbag
c
ballbag
c
ballbag
c
ballbag
c
ballbag
c
ballbag
PosativeSentiment.all
PosativeSentiment.all.find_or_create_by(word: :lovely, label: :Sentiment)
quit
c
ballbag
data[:lyrics].to_s.scan(/lovley/)
data[:lyrics].to_s.scan(/lovl/)
data[:lyrics].to_s.scan(/lovely/)
PosativeSentiment.all.find_or_create_by(word: :lovely, label: :Sentiment)
data[:lyrics] & PosativeSentiment.all.pluck(:word)
PosativeSentiment.all.pluck(:word)
data[:lyrics]
l
@
data[:lyrics].split & PosativeSentiment.all.pluck(:word)
data[:lyrics].join(" ").split & PosativeSentiment.all.pluck(:word)
sentiment_hash
c
sentiment_hash
quit
c
sentiment_hash
@
c
ballbag
sentiment_hash
@
c
key
k
v
k
v
c
k
v
c
v
c
v
c
v
c
v
c
v
k
additinal_words_hash(lyric_string, v.keys)
aa = {a: {}}
aa[:a].blank?
additinal_words
additinal_words.delete_if { |k, v| v.transform_values { |words_array| words_array[0]  } }
additinal_words
c
additinal_words
additinal_words.delete_if { |k, v| v.transform_values { |words_array| words_array[0]  } }
additinal_words
additinal_words.delete_if { |k, v| v.transform_values { |key, words_array| words_array[0]  } }
@
additinal_words.delete_if { |k, v| v.transform_values { |key, words_array| words_array[0]  } }
additinal_words
additinal_words.each { |k, v| v.transform_values { |key, words_array| words_array[0]  } }
c
key
k
v
v[0]
key
words_array
words_array[0]
words_array[0].delete
c
cd String
l
ls
quit
c
words_array
key
k
v
v.hash
v.class
v[0]
v.values
v.values[0]
v["#{key}"]
v["#{key}"][0]
additinal_words.each { |k, v| v.each { |key, value| v[key][0].pop } }
c
v
v[key][0]
v[key].shift
v
@
additinal_words.each { |k, v| v.each { |key, value| v[key].shift } }
c
Obscene.all
Obscene.all.find_by(word: :bitch)
Vulgar.all.find_by(word: :bitch)
Vulgar.all.find_or_create_by(word: :bitches)
Vulgar.all.find_or_create_by(word: :bitches).update(label: :Profanity)
Vulgar.all.find_or_create_by(word: :bitches)
quit
additinal_words.blank?
c
additinal_words
aa = True
aa = true
aa.class
aa = true
aa.class
quit
def my_meth
puts "hello"
end
my_meth.class
my_meth
quit
cd String
ls
cd
cd Array
ls
cd
cd Hash
;s
ls
cd
Hash.class
quit
aa = "t"
aa.class
quit
lyric_options = lyrics_directory(File.join(root, "text-lyrics"))
lyric_options.class
looper
looper.class
ls
index.class
aa = "string\n"
aa = "string\n".chomp
aa = "string".chomp
quit
(/[0-9]{0,3}/).match(index)
index
lyric_options
lyric_options[index]
lyric_options[1]
lyric_options[3]
@
(/[0-9]{0,3}/).match(index)
index.class == Integer
index
index.class == "Integer"
index = 1
index.class == "Integer"
index.class == Integer
index.class
index
(/[0-9]{0,3}/).match(index)
index
(/[0-9]{0,3}/).match(index)
(/[0-9]/).match(index)
(/[0-9]{0,3}/).match(index)
/\d/.match(index)
index
index = 1-
index = 10
/\d/.match(index)
index.class
index = "10"
/\d/.match(index)
(/\d/).match(index)
 lyric_options.include?(lyric_options[index.to_i])
c
quit
(/\d/).match(index)
c
 lyric_file = lyric_options[index.to_i]
 lyric_file
 lyric_file.class
 lyric_file = lyric_options[index.to_i]
lyric_options[index.to_i]
lyric_options
ls
lines = Hash.new { |h, k| h[k] = Hash.new(0) }
lines.class
aa = []
aa.class
aa = []
bb = {}
cc = {a: 0}
aa.count
bb.count
cc.count
aa = [nil]
aa.count
quit
syllable_word_count = syllable_count(word)
syllable_word_count.class
@
lines
c
lines
@
a.class
a_a
a_a.class
quit
quit
qui
quit
a_a_s
a_a_s.class
chars = data[:lyrics].join("\n").split(" ").join("")
chars
chars.gsub(/[^a-zA-Z]/, "").length
c
data["lyrics"]
data[:lyrics]
data[:lyrics].split(" ")
data[:lyrics].join(" ")
data[:lyrics].join(" ").split
aa = data[:lyrics].join(" ").split
aa[0..99]
aa[0..99].join(" ")
aa[0..99].join(" ").(" ")
aa[0..99].join(" ").join(" ")
aa[0..99].join(" ").split.join(" ")
aa[0..99].join(" ").split(" ")
aa[0..99].join(" ").split(" ").join("")
aa[0..99].join(" ").split(" ").join("").length
grade_level_score.class
grade_level_score
grade_level_score = (0.39 * avg_sentence_length + 11.8 * avg_syllable_per_word - 15.59)
grade_level_score
grade_level_score.class
cached_models = load_my_models
cached_models.class
file_name_json = File.join(root + "lyrics", a_a_s.title)
file_name_json.class
aa = File.open(file_name_json + ".json", "w") { |f| f.write(JSON.pretty_generate(a_a_s.as_json)) }
aa.class
c
aa = ["i hate coffee", "i love coffe"]
quit
Ocean.all
:q
quit
shoe-models
show-models
Onomatopoeium.all
quit
Drug.all
Drug.all.find_by(word: :star)
quit
Drug.all.find_by(word: :star)
Drug.all
l
quit
RockBand.all
;quit
lquit
RockBand.all
quit
Song.all.map {|a| a.delete }
Album.all.map {|a| a.delete }
quit
Onamatapium.all
Onomatopoeium.all
Drug.all
quit
Song.all
quit
Song.all
Song.all.map {|a| a.delete }
Album.all.map {|a| a.delete }
Artist.all.map {|a| a.delete }
quit
show-models
quit
Song.all
rails g
quit
Song.all
Artist.all
Drug.all
Crime.all
quit
@
filepaths
c
file
 data_hash
@
data_hash["Dataset"]
@
c
word
l
@
data_hash.has_key?("Quaternary")
!data_hash["Quaternary"].blank?
data_hash["Quaternary"].blank?
data_hash.has_key?("Tertiary")
data_hash.has_key?("Tertiary").blank?
data_hash["Tertiary"].blank?
c
data_hash["Tertiary"].constantize.
aa = data_hash["Tertiary"].constantize
aa
data_hash["Tertiary"].constantize
data_hash["Tertiary"]
c
data_hash["Tertiary"]
data_hash
quit
l
quit
c
@
data_hash["Dataset"]
data_hash
@
data_hash.has_key?("Quaternary") && !data_hash["Quaternary"].blank?
 data_hash.has_key?("Quaternary")
 data_hash["Tertiary"]
data_hash["Tertiary"].constantize
quit
data_hash.has_key?("Quaternary") && !data_hash["Quaternary"].blank?
word
data_hash
@
c
data_hash["Tertiary"].constantize
data_hash["Tertiary"].constantizec
@
aa = data_hash["Tertiary"]
aa.constantize.class
aa.constantize
data_hash["Tertiary"].constantize.find_or_create_by(word: word, primary: data_hash["Primary"], secondary: data_hash["Secondary"], tertiary: data_hash["Tertiary"])
c
data_hash
!data_hash["Quaternary"].blank?
data_hash["Quaternary"].blank?
data_hash.has_key?("Quaternary")
data_hash
@
ls
filepaths
c
quit
c
show-models
Kinetic.all
quit
c
cc
show-models
quit
data_hash["Tertiary"].constantize
data_hash["Tertiary"].constantize.find_or_create_by(
 word: word,
primary: first,
secondary: second,
tertiary: third,
)
c
data_hash["Tertiary"]
quit
Actor.all
quit
@
data_hash["Primary"].blank?
data_hash["Primary"]
data_hash["Primary"].present?
aa = "word"
aa.class
first.class
first
Actor.all
:vnew
quit
Actor.all
quit
Sports.all
Sport.all
quit
data_hash
quit
c
RelegiousTerms
RelegiousTerm.all
ReligionsTerm.all
SpiritualTerms.all
quit
show-models
Distance.all
Visual.all
Rails.application.eager_load!
ActiveRecord::Base.subclasses.sum(&:count)
Rails.application.eager_load!
ActiveRecord::Base.subclasses
ActiveRecord.descendents
ActiveRecord.descendants
ActiveRecord.descendants.collect {|a| a.name }
Rails.application.eager_load!
ActiveRecord::Base.subclasses
0
ActiveRecord::Base.subclasses[0]
Rails.application.eager_load!
  ApplicationRecord.descendants.collect { |type| type.name }
  ApplicationRecord.descendants.collect { |type| type.name }
.count
quit
aa = {}
aa[:one][:two][:three]
aa[:one][:two][:three] = 0
quit
aa = {a: {b:{c:{d:{e:{}}}}}}
aa = {a: {b:{c:{d:{e:1}}}}}
aa[:one][:two][:three][:four] = 0
aa[:a]
quit
@
dataset
dataset_words
@
dataset.constantize.where(words_found)
words_found
@
dataset.constantize.where(words: words_found)
dataset.constantize
dataset.constantize.where(word: words_found)
words_found = ["william shatner", "will ferrell"]
@
dataset.constantize.where(word: words_found)
@
c
Distance.all
quuit
s
ls
cd
ls
@
cd
@
c
ls
dataset
cached_models
quit
l
quit
c
quit
@
ls
sentiment_hash
sentiment_hash[:test]
sentiment_hash[:test] = "a"
sentiment_hash[:test][:tester]
sentiment_hash[:test][:tester] = "b"
Distance.first
Distance.first[:word]
quir
sentiment_hash[:one]
sentiment_hash[:one] = 0
sentiment_hash[:one][:two] = 0
sentiment_hash[:one][:two][:three] = 0
sentiment_hash[:one][:two][:three][:four] = 0
@
sentiment_hash[:one][:two][:three][:four] = 0
sentiment_hash[:one][:two][:three][:four]
sentiment_hash
quit
sentiment_hash[:one][:two][:three][:four] = "this is gonna have a GOTCHA"
sentiment_hash[:one][:two][:three] = "Yeh it night not though"
sentiment_hash[:one][:two] = "ok lets just wait and see"
sentiment_hash
def nested_hash
  Hash.new { |h, k| h[k] = nested_hash }
end
aa = nested_hash
aa[:one][:two] = "hopethis works"
aa[:one][:two][:three] = "hopethis works"
aa[:one][:two]
aa[:one][:three] = "test"
aa
aa[:one][:three][:four] = "why"
c
word_records.count
c
word_records.count
c
word_records.count
c
word_records.count
c
word_records.count
c
word_records.count
c
word_records.count
c
word_records.count
c
word_records.count
c
word_records.count
c
word_records.count
c
word_records.count
c
word_records.count
c
word_records.count
c
word_records.count
word_records
@
word_records
Distance.all
@
ls
cached_models
c
word_records
c
dataset_words = dataset.constantize.pluck(:word)
@
dataset
dataset.constantize
c
dataset
dataset.constantize
dataset.constantize.pluck(:word)
dataset.constantize.pluck(:word)[1]
dataset.constantize.pluck(:word)[1].length
dataset.constantize.pluck(:word)
@
c
@
dataset.constantize
dataset.constantize.where(words: words_found)
words_found
words_found.class
@
dataset.constantize.where(word: words_found)
c
found_term = data[:lyrics].to_s.scan(/#{record[:word]}/)
record
record[:quaternary].present?
h = Hash.new { |l, k| l[k] = Hash.new(&l.default_proc) }
h
aa = Hash.new { |l, k| l[k] = Hash.new(&l.default_proc) }
aa[:one][:two][:three][:four] = 0
aa[:one][:two][:three][:four][:5] = 0
aa[:one][:two][:three][:four][:five] = 0
aa[:two][:two][:three][:four][:five] = 0
aa[:three][:two][:three][:four][:five] = 0
aa[:three][:two][:three][:four][:six] = 0
aa
quit
Drug.all
Drugs.all
show-models
show-models.count
show-models
quit
Drug.all
quit
aa = "my/long/word/"
aa.split("/")
aa.split("/").camalize
bb = aa.split("/")
bb..map(&:camelize)
bb.map(&:camelize)
cd String
ls
filepaths
@
filepaths.split("Data")
filepaths.map {|a| a.split("data") }
filepaths.map {|a| a.split("data")[1].pop }
filepaths.map { |path| path.split("Data") }.map { |f| f[0].delete }
filepaths.map { |path| path.split("Data") }
@
filepaths.map { |path| path.split("Data") }
filepaths.map { |path| path.split("data") }
aa = filepaths.map { |path| path.split("data") }
aa.delete_if {|bb| bb[0] }
aa
!
aa = filepaths.map { |path| path.split("data") }
aa.delete_if {|bb| bb[0] }
aa = filepaths.map { |path| path.split("data") }
aa.delete_if {|f| f[0] }
aa
aa = filepaths.map { |path| path.split("data") }
aa = "this shizle"
aa.split(" ")
aa.split(" ")[0]
quit
paths = filepaths.select { |path| path.split("data")[1] }
paths = filepaths.map { |path| path.split("data")[1] }
@
2
quit
paths = filepaths.map { |path| path.split("data")[1] }
paths[0]
paths[0][-1]
File.extname(paths[0])
ls
sentiment_hash
c
sentiment_hash
Singer.all
Singer.find_by(word: heart)
Singer.find_by(word: :heart)
Singer.find_by(word: :heart).delete
Singer.find_by(word: :heart)
quit
c
@
color
root
quit
c
color
c
color
c
color
c
color
c
data
c
data
c
data
quit
c
@
c
Actor.all
uit
quit
filepaths
l
ls
@
filepaths = sub_dir(root)
quit
c
Weapon.all
Pistol.all
show-modes
show-models
quit
 ActiveRecord::Migration
cd  ActiveRecord::Migration
ls
table_name_options
Current
cd Current
ls
@@erbose
cd
cd ActiveRecord::Migration
proper_table_name
name
cd
ls
@
c
@
c
model_validation = sub_dir(model_directory)
@
c
model_validation = sub_dir(model_directory)
c
model_validation.present?
c
model_validation.map { |path|  File.basename(path, File.extname(path)) }
@
data_file
c
Smg.all
quit
c
quit
Carbine.all
@
Carbine.all
quit
c
@
data
e
cd e
ls
message
inspect
full_message
backtrace_locations
@
cd
@
ls
build_keys = File.basename(data_file, File.extname(data_file))
data_file
aa = data_file
aa..split("data")
aa.split("data")
File.basename(data_file, File.extname(aa.split("data"))
File.basename(data_file, File.extname(aa.split("data"))
!
File.basename(data_file, File.extname(aa))
aa.split("data")[1]
bb = aa.split("data")[1]
bb[-1]
bb
bb.split("/")
bb.split("/").compact
bb.split("/")
cd Array
ls
cd
bb.split("/").flatten
structure
build_keys
@
structure = data_file.split("data")[1]
data_keys = structure.split("/")
third = data_keys[2] ||= ""
third = data_keys[3] ||= ""
data_keys = structure.split("/").reject(&:empty?)
@
key_depth
data_keys
key_depth.offset(1)
cd key_depth
ls
cd
key_depth.to_s
key_depth.to_s.offset(1)
key_depth
data_keys[index]
data_keys
index
key_depth
index = offset - key_depth
index
offset
key_depth
1 - 1
data_keys[index]
token.constantize
token
ls
data_hash
token
Literature
Literature.constantize
"Literature".constantize
token.constantize
token.class
token.constantize
"Literature"
"Literature".class
Literature
token.constantize
token
token.uppercase
token.upper
cd token
ls
cd
token.capitalize
token.capitalize..constantize
token.capitalize.constantize
@
test = modelpaths.map { |f| File.basename(f, File.extname(f)) }
models_trim = modelpaths.map { |f| File.basename(f, File.extname(f)) }
@
data_trim = filepaths.map { |f| File.basename(f, File.extname(f)) }
@
models_trim & data_trim
!
@
 data_trim - models_trim
data_file
data = File.basename(data_file, File.extname(data_file))
unmigrated_models
unmigrated_models.include?(data)
unmigrated_models
data
data_file
data = File.basename(data_file, File.extname(data_file))
@
data_file
data = File.basename(data_file, File.extname(data_file))
aa = "file_name"
aa.camelize
aa.camelcase
aa.camelize
aa.classify
c
aa = [1,2,3]
bb = [1,3,4]
aa & bb
aa - bb
quit
c
cc
c
found_term = data[:lyrics].to_s.scan(/#{record[:word]}/)
record[:word]
record
c
sentiment_hash
c
sentiment_hash
c
cc
c
ccc
c
sentiment_hash
c
cc
c
sentiment_hash
Actor.all
aa = [1,2,3,4,5]
aa = [1,2,3,4,5,6,7,8,9,10]
bb = [1,2,3,4,5]
aa - bb
@
ls
token
token@
@
first = data_keys[0] ||= ""
second = data_keys[1] ||= ""
third = data_keys[2] ||= ""
data_keys
@
data_keys
data_keys.map { | path | File.basename(path, File.extname(path))
aa = data_keys.map { | path | File.basename(path, File.extname(path))
aa
data_keys
!
data_keys
aa = data_keys.map { | path | File.basename(path, File.extname(path))
aa
aa.class
!
aa = data_keys.each { | path | path.split(/\./)[0] if File.extname(path) }
aa = data_keys[1].split(/\./)[0] if File.extname(path) 
aa = data_keys[1].split(/\./)[0] if File.extname(data_keys[1]) 
File.basename(, File.extname(data_keys[1])
File.basename(data_keys[1], File.extname(data_keys[1])
!
File.basename(data_keys[1], File.extname(data_keys[1]))
@
File.basename(data_file[-1], File.extname(data_file[-1]))
data_file.split("data")
File.extname(data_file)
data_file.chomp(File.extname(fname))
data_file.chomp(File.extname(data_file))
Actor.all
quit
c
sentiment_hash
c
cc
c
ccc
c
cc
c
cc
c
sentiment_hash
@
record
record(:primary, :secondary, :tertiary, :quaternary)
record.pluck(:primary, :secondary, :tertiary, :quaternary)
record.all.pluck(:primary, :secondary, :tertiary, :quaternary)
record
record.pluck(:primary, :secondary, :tertiary, :quaternary)
record.class
@
record.to_a
cd record
l
ls
@attribute
@
cd
l
@
word_records
c
Actor.all
Actor.all.pluck(:word).first
Actor.all.pluck(:word)
Album.all.where(word: Actor.all.pluck(:word))
Album.first
Album.all
!
Album.all
Artist
show-models
Visual.all.where(word: Actor.all.pluck(:word))
Visual.all
Visual.all.where(word: Actor.all.pluck(:word))
Actor.all.pluck(:word)
@
 word_records
@
record
record.clas
record.class
record.select(:word)
record.select(:word).take 
record
record.select(:word).take 
record.class
cd Distance
ls
@symbol_column_to_string_name_hash
@symbol_column_to_string_name_hash.class
cd
@symbol_column_to_string_name_hash
Distance.symbol_column_to_string_name_hash
Distance.nested_attributes_options
Distance.implicit_order_column
Distance.nested_attributes_options?
record
record.to_h
record.nested_attributes_options
Distance.nested_attributes_options
l
@
word_records
record
@
 word_records
 word_records.pluck(:words)
 word_records[0]
 word_records[0].class
 word_records[0].to_s
 word_records[0].to_h
 word_records[0].to_a
@
word_records
word_records.select {|a| a.word == "far" }
word_records
c
quit
@
word_records = dataset.constantize.where(word: words_found).pluck(:id, :word)
c
word_records = dataset.constantize.where(word: words_found).pluck(:id, :word)
c
word_records = dataset.constantize.where(word: words_found).pluck(:id, :word)
c
word_records = dataset.constantize.where(word: words_found).pluck(:id, :word)
c
cc
c
word_records = dataset.constantize.where(word: words_found).pluck(:id, :word)
c
word_records = dataset.constantize.where(word: words_found).pluck(:id, :word)
word_records = dataset.constantize.where(word: words_found)
c
word_records = dataset.constantize.where(word: words_found)
c
word_records = dataset.constantize.where(word: words_found)
c
word_records = dataset.constantize.where(word: words_found)
c
word_records = dataset.constantize.where(word: words_found)
c
word_records = dataset.constantize.where(word: words_found)
c
word_records
c
word_records = dataset.constantize.where(word: words_found)
c
cc
word_records = dataset.constantize.where(word: words_found)
c
cc
c
cc
c
word_records = dataset.constantize.where(word: words_found)
word_records = dataset.constantize.where(word: words_found).pluck(:id, :word)
word_records.group
word_records.to_h
@
c
word_records
c
cc
c
cc
c
data_set
dataset
dataset.constantize
dataset.constantize.find(3)
dataset.constantize.find(3).class
dataset.constantize.find(3).word
dataset.constantize.find(3).pluck(:id)
@
l
@
c
cc
c
word_records = dataset.constantize.where(word: words_found).pluck(:id, :word, :primary)
word_records.group
word_records.group_by {|a| a[0] }
word_records
word_records << [1,"no","time"]
word_records.group_by {|a| a[0] }
aa = word_records.group_by {|a| a[0] }
aa[1]
aa[1].count
@
word_records.pluck(:id, :word, :primary, :secondary, :tertiary, :quaternary)
hashed_result = result.group_by { |a| a[0] }
result.group_by { |a| a[0] }
result
word_records.pluck(:id, :word, :primary, :secondary, :tertiary, :quaternary)
result = word_records.pluck(:id, :word, :primary, :secondary, :tertiary, :quaternary)
@
hashed_result = result.group_by { |a| a[0] }
hashed_result[3]
hashed_result[3].shift
hashed_result[3]
hashed_result
!
hashed_result
result = word_records.pluck(:id, :word, :primary, :secondary, :tertiary, :quaternary)
hashed_result = result.group_by { |a| a[0] }
hashed_result[3]
hashed_result[3][0]
hashed_result[3][0][0].shift
hashed_result[3][0][0]
hashed_result[3][0].shift
hashed_result[3][0]
hashed_result[3][0].count
k
record
record[0]
record[0].shift
record[0]
hashed_result = result.group_by { |a| a[0] }
c
hashed_result = result.group_by { |a| a[0] }
hashed_result
c
words = record[0][0].shift
words = record[0][0]
words = record[0]
words = record[0].shift
words = record[0]
c
words = record[0].shift
words
c
words
record
record[0]
@
c
record[0].reject { |w| w.empty? }
found_term = data[:lyrics].to_s.scan(/#{w[0]}/)
found_term = data[:lyrics].to_s.scan(/#{record[0]}/)
@
data[:lyrics]
data[:lyrics].to_s
@
data[:lyrics].to_s.scan(/#{record[0]}/)
record
record[0]
record[0][0]
@
data[:lyrics].to_s.scan(/#{record[0][0]}/)
c
word_records
quit
c
sentiment_hash
@
c
@
dataset_words
quit
c
extention_removed = datasets.map { |data| data.chomp(File.extname(data)) }
@
extention_removed = datasets.map { |data| data.chomp(File.extname(data)) }
extention_removed
@
data_struct
@
datasets = get_dataset_directory(data_directory)
data_struct
data.split("Projects")[1]
data.split("Projects")
data.split("Projects")[1]
c
data_struct
c
path
data
path
data.split("/")
data.split("/").join
data.split("/").join('/")
!
data.split("/").join('/")
data.split("/").join("/")
!
data.split("/").join("/")
data.split("/").pop
data
aa = data.split("/").pop
data.split("/").pop.join("/")
data.split("/").delete
aa = data.split("/").pop
aa
aa = data.split("/")
aa.pop
aa
data_struct
data
path
c
path.class
path.to_s
path.to_s.chomp
path[0]
sh "git add #{path[0]}/*"
data
sh "git commit -m" + " " + "added #{data}"
sh 'git commit -m' + "ADDED: #{data}"
sh 'git commit -m' + " " + "ADDED: #{data}"
sh 'git commit -m' "ADDED: #{data}"
sh 'git commit -m' \"ADDED: #{data}\"
sh 'git commit -m' + \"ADDED: #{data}\"
sh 'git commit -m' + " " + \"ADDED: #{data}\"
!
sh 'git commit -m' + " " + \"ADDED: #{data}\"
sh "git commit -m \"added #{data}\""
@
data
data_root = File.basename(data, File.extname(data))
data
@
data_root = File.basename(f, File.extname(f))
f
data_root = File.basename(fp, File.extname(fp))
fp
@
data_root = File.basename(fp, File.extname(fp))
fp
data_root = File.basename(fp, File.extname(fp))
data
c
aa = "tit"
aa.class
data_struct
quit
data_struct
@
filepath
filepath.join("/")
filepath.join("/").split("data")
filepath.join("/").seperator
filepath.join("/").separator
aa = "a/b/c/d"
File::Separator
cd aa
ls
cd
aa.partition(/\//)
aa.partition("/")
aa.partition("/").count
aa.partition("/").class
aa = "a"
aa.partition("/")
datasets
@
data
filepath
filepath = data.split("data")
filepath = data.split("data")[1]
filepath = data.split("data")[1].split
filepath = data.split("data")[1].split("/")
@
filepath.pop
filepath
filepath = data.split("data")[1].split("/")
filepath.shift
filepath
c
cccc
c
cc
c
data_struct
c
key
data
data[0]
ls
data_directory
data_directory + data[0]
data_directory + "/" + data[0]
@
cd Array
@
data_keys = structure.split("/").reject(&:empty?)
c
@
data_keys
@
data_hash = read_file_build_hash(data_file)
c
data_file
data_hash = read_file_build_hash(data_file)
@
c
Actor.all
Song.all
quit
c
unmigrated_models.include?(data)
data
unmigrated_models
filepaths
@
data_trim
@
models_trim
l
@
unmigrated_models.include?(data)
data
unmigrated_models
models_trim
data_trim
@
unmigrated_models
@
option
option[0]
option[0].to_h
option[0] l
option[0]
aa = [1,2,3,4,5]
aa = []
aa
aa.include?(1)
aa.include?("there")
show-models
quit
aa = {a: "bb = []"}
aa[:a]
aa[:a].class
cc = {}
cc = {}.class
aa[:a].to_o
aa[:a].to_c
aa = {a: 'bb = []'}
aa[:a]
aa[:a].class
aa[:a].to_a
cd String
ls
quit
show-models
show-models grep
show-models grep yeast
show-models grep Yeast
quit
words = "booster bailings balling failing"
words.scan /(?<=\b)b\w*?(?=ing\b)/
words.scan /(?<=\b)b\w*?(?=(ing|ed)\b)/
words = "booster bailings balling failing balled"
words.scan /(?<=\b)b\w*?(?=(ing|ed)\b)/
quit
words = data[:lyrics].join.to_s
words.scan(/(?<=\b)b\w*?(?=(ize|ise|ify|fy|en|ate)\b)/)
words.scan(/(?<=\b)b\w*?(?=(ize)\b)/)
words = "booster bailings balling failing balled"
words.scan(/(?<=\b)b\w*?(?=(ize)\b)/)
words.scan(/(?<=\b)b\w*?(?=(ize|ise|ify|fy|en|ate)\b)/)
words.scan(/(?<=\b)b\w*?(?=(ing|ize|ise|ify|fy|en|ate)\b)/)
words = data[:lyrics].join("\n").to_s
words = data[:lyrics].join("\n").regex("\n", " ")
words = data[:lyrics].join("\n").gsub("\n", " ")
words.scan(/(?<=\b)b\w*?(?=(ing|ize|ise|ify|fy|en|ate)\b)/)
words.scan(/(?<=\b)b\w*?(?=(s|ize|ise|ify|fy|en|ate)\b)/)
words.scan(/\bb[a-zA-Z]*(?=ing\b)/)
words.scan(/\bb[a-zA-Z]*(?=er\b)/)
words
words.class
words.scan(/\bb[a-zA-Z]*(?=ts\b)/)
str = "blathering fumbling blinging bérgering blings"
str.scan(/\bb[a-zA-Z]*(?=ing\b)/)
words.scan(/\bb[a-zA-Z]*(?=ies\b)/)
words.scan(/\b[a-zA-Z]*(?=ies\b)/)
words.scan(/\bs[a-zA-Z]*(?=ies\b)/)
words.scan(/(?<=\b)\w*?(?=(s|ize|ise|ify|fy|en|ate)\b)/)
words.scan(/(?<=\b)\w*?(?=(ize|ise|ify|fy|en|ate)\b)/)
words.scan(/^[-\w]+:\s*(?:(?!(?:ed|ing)\b)\w)+\b.+/)
words.scan(/(?<=\b)\w*?(?=[ize|ise|ify|fy|en|ate]\b)/)
words
words.scan(/(?<=\b)\w*?(?=[ize|ise|ify|fy|en|ate]\b)/)
words.scan(/(?<=\b)\w*?(?=(ize|ise|ify|fy|en|ate)\b)/)
words.scan(/(?<=\b)s\w*?(?=(ize|ise|ify|fy|en|ate)\b)/)
words = data[:lyrics].join.to_s
@
words = data[:lyrics].join.to_s
quit
words = "booster bailings balling failing balled"
words = "booster bailings balling failing"
words
words.scan(/(?<=\b)\w*?(?=[ing]/)
words.scan(/(?<=\b)\w*?(?=[ing]/))
words.scan(/(?<=\b)\w*?(?=[ing])\)
!
words.scan(/(?<=\b)\w*?(?=[ing])\)
words.scan(/(?<=\b)\w*?(?=[ing]))
words.scan(/(?<=\b)\w*?(?=[ing]\)\)
!
words.scan(/(?<=\b)\w*?(?=[ing])\)
words.scan(/(?<=\b)\w*?(?=ing)\)
words.scan(/(?<=\b)\w*?(?=ing))
!
words.scan(/(?<=\b)s\w*?(?=[ize|ise|ify|fy|en|ate]\b)/)
words.scan(/(?<=\b)\w*?(?=[ize|ise|ify|fy|en|ate]\b)/)
words
words.scan(/([a-z]+ing)/)
words.scan(/([a-z]+(ing|er))/)
words.scan(/([a-z]+(ing|er))/).to_h
words.scan(/([a-z]+(ing|er))/).flatten.uniq
words.scan(/([a-z]+(ing|er))/).uniq
words.scan(/([a-z]+(ing|er))/).uniqquit
quit
quit
words.scan(/([a-z]+(ing|er))/).to_h
words
[200~words.scan(/([a-z]+(ing|er))\s/).to_h~
[200~words.scan(/([a-z]+(ing|er)\s)/)
words.scan(/([a-z]+(ing|er)\s)/)
words.scan(/([a-z]+(ize|ise|ify|fy|en|ate)\s)/).to_h
verb_suffix
verb_suffix = words.scan(/([a-z]+(ize|ise|ify|fy|en|ate)\s)/).to_h
adjective_suffix = words.scan(/([a-z]+(less|ive|ish|ious|ic|ical|ful|esque|al|ible|able)\s)/).to_h
aa = " this is my nice string "
aa.sqeeze
cd String
ls
cd 
aa.strip
quit
aa = [[
!
aa = [[" word", " some"]]
aa.map {|a| a[0].srrip }
aa.map {|a| a[0].strip }
ls
verb_suffix
verb_suffix.to_h
aa = ["word is a long sentence", "lone sentence"]
words = data[:lyrics].join("\n").tr("\n", " ")
words = data[:lyrics].join("\n")
words = data[:lyrics].join("\s")
quit
c
v
c
record
record.word
c
suffix
quit
Temperature.all
quit
Temperature.find_by(name: :cold)
Temperature.find_by(word: :cold)
Temperature.find_by(word: :coldy)
$?
$?.exitstatus
$?.class
cd $?
ls
cd
$?.inspect
$?.pretty_print_cycle
$?.to_param
Temperature.find_or_create_by(word: :cold)
$?.inspect
$?
$? = 0
$? = "0"
@
$?
$?.inspect == nil
$?.inspect
$?
$? == nil
c
suffix
sentiment_hash.merge(suffix)
c
sentiment_hash
sentiment_hash.merge(suffix)
aa = {a: 1}
aa[:thing] = 1
aa
suffix
c
suffix
quit
suffix
q
suffix
aa = ["the', "man" "went", "home"]
aa = ["the', "man", "went", "home"]
aa = ["the", "man", "went", "home"]
aa[1]
aa[0]
aa[0] = a
aa = "aaaatheBig1@gmail"
/(?=\D*\d)/.match("aa")
/(?=\D*\d)/.match(aa)
/aa/.match((?=\D*\d))
/aa/.match(/(?=\D*\d)/)
/aa/.match("(?=\D*\d)")
aa
/(?=\D*\d)/.match(aa)
/[0-9]/.match(aa)
/(?=\D*\d)/.match(aa)
/#{aa}/.match((?=\D*\d))
/#{aa}/.match("(?=\D*\d)")
/#{aa}/.match("\d)")
/#{aa}/.match("\d")
/#{aa}/.match(\d)
/#{aa}/.match(/\d/)
/aa/.match(/\d/)
aa.match(/\d/)
aa.match((?=\D*\d)/.match(aa))
aa.match(/(?=\D*\d)/.match(aa)/)
aa.match(/(?=\D*\d)/)
aa.match(/(?=\\d)/)
aa.match(/\d/)
aa.match()
aa = "find meEND"
aa.match(/(?:(?!{END}).)*/)
aa.match(/(?:(?!{E}).)*/)
quit
suffix
c
suffix
c
suffix
c
suffix
c
suffix
c
suffix
quit
c
suffix
a_a_s
@
a_a_s.update(lexicon: suffix)
a_a_s
!
a_a_s
c
a_a_s
song
Song
c
suffix
a_a_s.update(lexicon: suffix)
suffix
Song
v
c
Fabric.all
c
suffix
c
a_a_s.update(lexicon: suffix)
suffix
suffix.class
Song
a_a_s
suffix
aa = {}
aa[:tester] = suffix
@
c
@
a_a_s.update(lexicon: :random)
suffix
suffix.class
Song
@
suffix
a_a_s.update(lexicon: suffix)
c
@
aa = {a: 1}
a_a_s.update(lexicon: aa)
aa
aa.class
a_a_s
a_a
a_a_s
Song.all
quit
Song
quit
data
unmigrated_models
ls
filepaths
c
Song
a_a_s.update(vocabulary: suffix)
suffix
aa = [1,2,3,4,5]
aa = ["one", "two", "three"]
aa.to_s 
aa.to_s.scan(/one/)
aa.to_s.scan(/one/).present?
cd Array
l
ls
aa.to_s.scan(/one/).present?
aa = ["one", "two", "three"]
aa.to_s.scan(/one/)
$?
aa
$?
1 + 1
$?
quit
aa = ["one", "two", "three"]
aa.scan(/(\w+(?=(ing|er)))/)
aa.to_s.scan(/(\w+(?=(ing|er)))/)
aa = ["thinking", "think", "thinker"]
aa.to_s.scan(/(\w+(?=(ing|er)))/)
aa.to_s.scan(/(\w+(?=(ing|er)))/).to_h
aa.to_s.scan(/(\w+(?=(ing|er)))/).group
ls
lexicon_noun(words)
words
lexicon_noun(words)
aa.to_s.scan(/(\w+(?=(ing|er)+))/).group
c
data
datafile["Dataset"]
datafile
data_hash
quit
data_hash
data_hash["Dataset"].delete_if { |w| w.split.count > 1 }
c
additinal_words_hash(word_dict, data_hash["Dataset"])
word_dict
File.read(word_dict)
File.foreach(word_dict) { |w| (data[:words] || []) << w.chomp }
File.foreach(word_dict) { |w| (word_hash_to_string[:words] || []) << w.chomp }
@
File.foreach(word_dict) { |w| (word_hash_to_string[:words] || []) << w.chomp }
word_hash_to_string
@
additinal_words_hash(data[:words].to_s, data_hash["Dataset"])
additinal_words_hash(word_hash_to_string[:words].to_s, data_hash["Dataset"])
word_hash_to_string[:words].count
word_hash_to_string[:words].to_s
@
data_hash
data_file
datafile
@
name
File.open("result/#{name}.json", "w") { |f| f.write(JSON.pretty_generate(word_hash_to_string.as_json)) }
result
c
cc
c
result.count
result
result.class
aa = ["think", "thinking", "thinks"]
aa.scan(/\b(#{word.strip})([a-zA-Z]+?)\b(?=\s)\b/).flatten.uniq
aa.scan(/\b(think)([a-zA-Z]+?)\b(?=\s)\b/).flatten.uniq
aa.to_s.scan(/\b(think)([a-zA-Z]+?)\b(?=\s)\b/).flatten.uniq
aa.to_s.scan(/\b("think")([a-zA-Z]+?)\b(?=\s)\b/).flatten.uniq
aa.to_s.scan(/\bthink([a-zA-Z]+?)\b(?=\s)\b/).flatten.uniq
aa.to_s.scan(/\b(think)([a-zA-Z]+?)\b(?=\s)\b/).flatten.uniq
aa.to_s.scan(/\b("think")([a-zA-Z]+?)\b(?=\s)\b/).flatten.uniq
aa.to_s.scan(/\b(#{think})([a-zA-Z]+?)\b(?=\s)\b/).flatten.uniq
aa.to_s.scan(/\b"think"([a-zA-Z]+?)\b(?=\s)\b/).flatten.uniq
aa.to_s.scan(/(think)/)
aa.to_s.scan(/(think)[a-z]/)
aa.to_s.scan(/(think)[a-z]+?/)
aa.to_s.scan(/[a-z]+?/)
aa.to_s.scan(/\b(think)([a-z]+)\b(?=\s)/)
aa
aa.to_s.scan(/(think)([a-z]+)(?=\s)/)
think.pluralize
aa "think".class
aa = "think"
aa.pluralize
aa.pluralize  
cd String
ls
quit
ls
dict_words
dict_words.count
@
data_hash
aa = "i have some words"
aa.split
bb = "there"
vv.split
bb.split
data_hash["Dataset"]
data_hash["Dataset"][0]
data_hash["Dataset"][0].split
data_hash["Dataset"][0].split > 1
if w.split > 1
puts "yes"
end
if data_hash["Dataset"][0].split > 1
puts "yes"
end
data_filterd = data_hash["Dataset"].map { |w| w if w.split.count > 1 }
data_filterd
data_filterd = data_hash["Dataset"].delete_if { |w| w if w.split.count > 1 }
string_doc.scan(/("#{w}")([a-z]+)(?=\s)/)
string_doc.count
string_doc.class
string_doc.length
string_doc.[0.10]
string_doc.[0..10]
w
#{w}
puts #{w}
!
puts #{w}
sentiment
@
w
word
string_doc.scan(/("#{word}")([a-z]+)(?=\s)/)
string_doc.scan(/("the")([a-z]+)(?=\s)/)
string_doc.scan(/(the)/)
string_doc.scan(/(the)([a-z]+)(?=\s)/)
string_doc.scan(/(the)([a-z]+)/)
word = the
word = "the"
@
string_doc.scan(/(word)([a-z]+)/)
string_doc.scan(/("#{word}")([a-z]+)/)
string_doc.scan(/(\"#{word}\")([a-z]+)/)
string_doc.scan(/(\"\#{word}\")([a-z]+)/)
word = "the"
string_doc.scan(/(\"#{word}\")([a-z]+)/)
string_doc.scan(/(\"word\")([a-z]+)/)
string_doc.scan(/(word)([a-z]+)/)
@
string_doc.scan(/("test")([a-z]+)/)
string_doc.scan(/(\"test\")([a-z]+)/)
string_doc.scan(/(test)([a-z]+)/)
@
word.class
string_doc.scan(/test([a-z]+)/)
@
string_doc.scan(/#{word}([a-z]+)/)
string_doc.scan(/"#{word}"([a-z]+)/)
string_doc.scan(/#{word}([a-z]+)/)
word = "the"
string_doc.scan(/#{word}([a-z]+)/)
string_doc.scan(/"#{word}"([a-z]+)/)
string_doc.scan(/#{word}([a-z]+)/)
string_doc.scan(/word([a-z]+)/)
word
string_doc.scan(/word([a-z]+)/)
string_doc.scan(/the([a-z]+)/)
string_doc.scan(/\"#{word}\"([a-z]+)/)
word = "the"
string_doc.scan(/\"#{word}\"([a-z]+)/)
string_doc.scan(/\"word\"([a-z]+)/)
string_doc.scan(/word([a-z]+)/)
word = "the"
string_doc.scan(/#{Regexp.escape(word)}([a-z]+)/)
word
hashy[word]
word = "word"
word = "think"
string_doc.scan(/#{Regexp.escape(word)}([a-z]+)/)
string_doc.scan(/#{Regexp.escape(word)}([a-z]+)/).uniq
string_doc.scan(/#{Regexp.escape(word)}([a-z]+)/).uniq.flatten
word = "think"
string_doc.scan(/#{Regexp.escape(word)}([a-z]+)(?=\s)/).uniq.flatten
string_doc.scan(/#{Regexp.escape(word)}([a-z]+(?!\s)).uniq.flatten
string_doc.scan(/#{Regexp.escape(word)}([a-z]+)(?!\s).uniq.flatten
!
string_doc.scan(/#{Regexp.escape(word)}([a-z]+)(?!\s).uniq.flatten
string_doc.scan(/#{Regexp.escape(word)}([a-z]+)(?! ).uniq.flatten
string_doc.scan(/#{Regexp.escape(word)}([a-z]+)(?!).uniq.flatten
string_doc.scan(/#{Regexp.escape(word)}([a-z]+)(?!)/).uniq.flatten
string_doc.scan(/#{Regexp.escape(word)}([a-z]+)(?! )/).uniq.flatten
string_doc.scan(/#{Regexp.escape(word)}([a-z]+)(?!\s)/).uniq.flatten
word
string_doc.scan(/\b#{Regexp.escape(word)}([a-z]+)(?!\s)/).uniq.flatten
string_doc.scan(/\b#{Regexp.escape(word)}([a-z]+)(?!\s)\b/).uniq.flatten
string_doc.scan(/thinkably/).uniq.flatten
string_doc.scan(/thinkling/).uniq.flatten
quit
list.map! { |suffix| think + suffix }
c
list.map! { |suffix| think + suffix }
c
list.map! { |suffix| think + suffix }
c
list.map! { |suffix| think + suffix }
list
cd Array
ls
list.map! { |suffix| think + suffix }
cd
list.map! { |suffix| think + suffix }
datafile
datafile.split[-2]
datafile[-2]
datafile.split("/")
datafile.split("/")[-2]
string_doc.scan(/\b([a-z]+)(?=#{Regexp.escape(word)})\b/).uniq.flatten
string_doc = ["unease", "disease"]
string_doc.scan(/\b([a-z]+)(?=#{Regexp.escape(word)})\b/).uniq.flatten
string_doc.scan(/\b([a-z]+)(?=#{Regexp.escape(ease)})\b/).uniq.flatten
string_doc.scan(/\b([a-z]+)(?=#{Regexp.escape("ease")})\b/).uniq.flatten
string_doc.to_s.scan(/\b([a-z]+)(?=#{Regexp.escape("ease")})\b/).uniq.flatten
string_doc.to_s.scan(/\b([a-z]+)(?=#{Regexp.escape(ease)})\b/).uniq.flatten
string_doc.to_s.scan(/\b([a-z]+)(?=ease)\b/).uniq.flatten
string_doc.to_s.scan(/([a-z]+)(?=ease)/).uniq.flatten
string_doc.to_s.scan(/\b([a-z]+)(?=ease)/).uniq.flatten
string_doc.to_s.scan(/\b([a-z]+)(?=ease)\b/).uniq.flatten
string_doc.to_s.scan(/\b([a-z]+)(?=ease)/).uniq.flatten
string_doc.to_s.scan(/\b(dis|un)(?=ease)/).uniq.flatten
string_doc = ["unease", "disease"]
string_doc.to_s.scan(/\b(dis|un)(?=ease)/).uniq.flatten
string_doc = ["unease", "disease", "wease"]
string_doc.to_s.scan(/\b(dis|un)(?=ease)/).uniq.flatten
string_doc.to_s.scan(/\b(de|dis|ex|il|im|in|mis|non|pre|pro|re|un)(?=ease)/).uniq.flatten
string_doc = ["unease", "disease", "wease", "ilease"]
string_doc.to_s.scan(/\b(de|dis|ex|il|im|in|mis|non|pre|pro|re|un)(?=ease)/).uniq.flatten
string_doc = ["unease", "disease", "wease", "ilease"]
aa.scan(/\b#{Regexp.escape(word)}(?=(ed|en|er|ing|ize|ise))\b/).uniq.flatten
string_doc.scan(/\b#{Regexp.escape(ease)}(?=(ed|en|er|ing|ize|ise))\b/).uniq.flatten
string_doc.scan(/\b#{Regexp.escape("ease")}(?=(ed|en|er|ing|ize|ise))\b/).uniq.flatten
string_doc.to_s.scan(/\b#{Regexp.escape("ease")}(?=(ed|en|er|ing|ize|ise))\b/).uniq.flatten
string_doc.to_s.scan(/\b#{Regexp.escape("ease")}(?=(ed|en|er|ing|ize|ise))/).uniq.flatten
string_doc.to_s.scan(/#{Regexp.escape("ease")}(?=(ed|en|er|ing|ize|ise))/).uniq.flatten
string_doc = ["unease", "disease", "wease", "diseasing"]
string_doc.to_s.scan(/#{Regexp.escape("ease")}(?=(ed|en|er|ing|ize|ise))/).uniq.flatten
string_doc = ["unease", "disease", "wease", "diseaseing"]
string_doc.to_s.scan(/#{Regexp.escape("ease")}(?=(ed|en|er|ing|ize|ise))/).uniq.flatten
string_doc.to_s.scan(/\b#{Regexp.escape("ease")}(?=(ed|en|er|ing|ize|ise))\b/).uniq.flatten
string_doc.to_s.scan(/\b#{Regexp.escape("ease")}(?=(ed|en|er|ing|ize|ise))/).uniq.flatten
string_doc.to_s.scan(/#{Regexp.escape("ease")}(?=(ed|en|er|ing|ize|ise))/).uniq.flatten
aa = "word"
aa = "thinking"
aa.match((ing|er|ed))
aa.match(/(ing|er|ed)/)
aa.match(/(ing|er|ed)/).count
bb = aa.match(/(ing|er|ed)/)
bb.count
bb
bb = aa.scan(/(ing|er|ed)/)
@
ls
reorganised
adjective
adjective = data.to_s.scan(/([a-z]+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y))/)
data
adjective = data.to_s.scan(/([a-z]+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y))\b/)
adjective = data.to_s.scan(/([a-z]+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y)\b)/)
adjective = data.to_s.scan(/\b([a-z]+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y))/)
adjective = data.to_s.scan(/\b\w+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y))/)
adjective = data.to_s.scan(/\b(\w+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y))/)
adjective = data.to_s.scan(/([a-z]+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y)\b)$/)
adjective = data.to_s.scan(/([a-z]+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y)$)/)
c
reorganised
c
adjective
data
c
data
adjective
data.to_s.scan(/([a-z]+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y))/)
data.to_s.scan(/([a-z]+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y))$/)
data.to_s.scan(/([a-z]+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y)$)/)
data.to_s.scan(/([a-z]+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y)\z)/)
data.to_s.scan(/([a-z]+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y))/)
data.to_s.scan(/(\w)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y))/)
data.to_s.scan(/(\w+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y))/)
data.to_s.scan(/(\w+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y))\z/)
data.to_s.scan(/(\w+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y)\z)/)
data.to_s.scan(/(\w+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y)$)/)
data.to_s.scan(/(\w+)(?=(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y))$/)
data
data.to_s.scan(/([a-z]+)(ic)$/)
data.to_s.scan(/([a-z]+)(ic)/)
data.to_s.scan(/([a-z]+)(ic)\b/)
data.to_s.scan(/\b([a-z]+)(ic)\b/)
reorganised
c
reorganised
c
adjective
adjective.map! { |arry| [arry[0] + word[1]] }
adjective.map! { |arry| [arry[0] + arry[1]] }
adjective.map! { |arry| [arry[0] + arry[1]].flatten }
adjective.map! { |arry| [arry[0] + arry[1]] }
!
@
adjective = data.to_s.scan(/\b([a-z]+)(able|ible|al|ant|ary|ful|ic|ious|ous|ive|less|y)\b/)
adjective.map! { |arry| [arry[0] + arry[1]] }
c
remaped = adjective.map! { |arry| [arry[0] + arry[1]] }
remaped.flatten
(hashy[:adjective][] || []) << remaped
(hashy[:adjective]|| []) << remaped
hashy
c
reorganised
c
(hashy[:adjective] || []) << remaped.flatten
hashy
file_name
File.open("new_data/#{root_d}/#{file_name}.json", "w") { |f| f.write(JSON.pretty_generate(reorganised.as_json)) }
reorganised
root_d
verb = data.to_s.scan(/\b([a-z]+)(ed|en|er|ing|ize|ise|)\b/)
data = ["caravaggio", "michelangelo", "raphael"]
data.to_s.scan(/\b([a-z]+)(ed|en|er|ing|ize|ise|)\b/)
data.to_s.scan(/\b([a-z]+)\b/)
data = ["caravaggio", "michelangelo", "raphael"]
data.to_s.scan(/\b([a-z]+)(?=(ed|en|er|ing|ize|ise|))\b/)
data.to_s.scan(/\b([a-z]+)(?=(ed|en|er|ing|ize|ise|))$\b/)
data.to_s.scan(/([a-z]+)(?=(ed|en|er|ing|ize|ise|))/)
data.to_s.scan(/([a-z]+)(?=(ed|en|er|ing|ize|ise|)$)/)
data.to_s.scan(/([a-z]+)(?=(ed|en|er|ing|ize|ise|))/)
c
data_directory = datafile.split("data")
data_directory[1].split
@
data_directory[1]
data_directory[1].split("/")
data_directory[1].split("/").flatten
path_hierarchy
v
c
filename = File.basename(path_hierarchy, File.extname(path_hierarchy.join("/")))
path_hierarchy.join("/")
path_hierarchy[-1]
File.basename(path_hierarchy, File.extname(path_hierarchy[-1]))
path_hierarchy[-1]
path_hierarchy[-1].class
c
File.read(datafile)
filename = File.basename(path_hierarchy[-1], File.extname(path_hierarchy[-1]))
c
data_hash
path_hierarchy
final_directory
FileUtils.mkdir_p(final_directory)
final_directory
FileUtils.mkdir_p(final_directory)
c
ls
filename
c
@
final_directory
filename}
filename
c
Color.all
show-models
YeastBread.all
quit
structure = extention_removed.split("data")[1]
YeastBread.all
show-models
VisualVerb.all
quit
reflexive.all
quit
path_hierarchy
datafile
path_hierarchy
c
@
datafile.split("/")
datafile.split("data_txt")[1]
datafile.split("data_txt")[1].split
datafile.split("data_txt")[1].split("/")
aa = ["the", "fucking", "twat",]
aa
quit
aa = "a/b/c/d"
aa.split("/")
aa = "a"
aa.split("/")
directory_hierarchy
name
c
@
reorganised
@
reorganised
temp
c
temp
test_data/#{directory_hierarchy}/#{name}_#{k}.json
"test_data/#{directory_hierarchy}/#{name}_#{k}.json"
k
k.to_s
c
file_joined = "#{name}" + "#{k}"
c
reorganised
c
reorganised
c
reorganised
c
reorganised
c
file_joined = "#{name}" + "_" + "#{k}" + ".json"
c
file_joined 
file_joined
c
file_joined
directory_hierarchy
directory_hierarchy.join("/")
c
cdestination = "test_data" + "/" + directory_hierarchy.split("/")
c
dir = directory_hierarchy.pop
directory_dest = dir.join("/") + "#{name}"
dir.class
directory_dest = "#{dir}" + "#{name}"
directory_hierarchy
dir.class == String
dir.class == "String"
dir
directory_hierarchy
reorganised
@
dir
directory_dest = dir.join("/") + "#{name}"
directory_dest = directory_hierarchy.join("/") + "#{name}"
directory_dest = directory_hierarchy.join("/") + "/" + "#{name}"
directory_dest = "#{dir}" + "#{name}"
c
file_destination.join("/")
directory_hierarchy
directory_hierarchy = datafile.split("data_json")[1].split("/")
directory_hierarchy.shift
directory_hierarchy
file_destination = directory_hierarchy
file_destination.join("/")
c
@
file_destination
directory_hierarchy
directory_hierarchy.class
file_destination
directory_hierarchy.pop
file_destination
cd Array
ls
quit
file_destination
cd file_destination
ls
cd
file_destination.inspect
file_destination.object_id
@
file_destination.object_id
directory_hierarchy
directory_hierarchy.object_id
c
file_hierarchy
File.open("#{file_hierarchy}", "w") { |f| f.write(JSON.pretty_generate(reorganised.as_json)) }
c
test_data/#{file_hierarchy}
!
File.open("test_data/#{file_hierarchy}", "w") { |f| f.write(JSON.pretty_generate(reorganised.as_json)) }
file_hierarchy
name
#{partial_path}/#{name}/#{extention}
partial_path/name/extention
partial_path name extention
name
partial_path
c
@
cpartial_path
partial_path
name
extention
partial_path.pop
show-models
Vulgar.all
ChickenGrill.all
quit
data_directory = datafile.split("data_txt")
c
path_hierarchy = data_directory[1].split("/")
c
path_hierarchy
c
words
c
data_hash
c
path_hierarchy
filename
final_directory = "/Users/shadowchaser/Code/Ruby/Projects/music/scripts/data_json/" + path_hierarchy.join("/")
c
FileUtils.mkdir_p(final_directory)
File.open("#{final_directory}/#{filename}.json", "w") { |f| f.write(JSON.pretty_generate(data_hash.as_json)) }
data_hash
final_directory = "/Users/shadowchaser/Code/Ruby/Projects/music/scripts/data_json/" + path_hierarchy.join("/")
c
data
 data[:lyrics].map!(&:downcase)
@
root = "#{home}/Code/Ruby/Projects/#{app_name}/scripts/"
datafiles = data_directory(root)
@
root = "#{home}/Code/Ruby/Projects/#{app_name}/scripts/two-data-sets/data_json"
c
name = File.basename(datafile, File.extname(datafile))
c
data_hash = JSON.parse(File.read(datafile))
c
File.foreach(directory) { |line| dict_words << line.chop }
dict_words[0..2]
@
c
data_hash["Dataset"]
c
prefix
prefix.class
aa = ["prefix"]
aa[0]
aa[0].constantize
aa[0].map { |pre| pre + word }
c
root_d = datafile.split("/")[-2]
datafile
"lexicon/#{root_d}/#{name}.json"
c
dict_results
c
@
c
dict_results
quit
c
"lexicon/#{root_d}"
quit
Masculine.all
quit
c
Masculine.all.present?
Masculine.all.any?
Masculine.all.exists?
Masculine.ids?
Masculine.id
Masculine.id?
Masculine.ids
Masculine.count
Masculine.all.map {|a| a.delete }
Masculine.ids
Masculine.ids.present?
Masculin.ids.present?
Phobia.all
Phobias.all
Phobium.all
quit
Phobium.all
Phobia.all
quit
Masculin.ids.present?
Masculine.ids.present?
c
name = File.basename(datafile, File.extname(datafile))
c
root_d = datafile.split("/")[-2]
dataset
data_file
data_files
datafiles
name
data_hash
aa = ["a", "b", "c", "d"]
pkaj
aa
aa.delete_if {|a| a == "b" }
aa
c
data_hash["Dataset"]
data_hash["Dataset"].delete_if { |w| w if w.split.count > 1 }
data_hash["Dataset"]
datafile.split("data_txt")
datafile.split("data_txt")[1]
datafile.split("data_txt")[1].split("/")
aa = ["a", "b", "c", "d"]
aa = ["a", "b", "c", "d", ""]
aa.comapct
aa.compact
aa.compact_blank
c
root = "#{home}/Code/Ruby/Projects/#{app_name}/two-data-sets/data_txt"
root
c
datafiles = data_directory(root)
root
c
datafiles = data_directory(root)
c
datafiles = data_directory(root)
root
@
c
name = File.basename(datafile, File.extname(datafile))
c
data_hash = JSON.parse(File.read(datafile))
c
directory = "/usr/share/dict/words"
c
File.foreach(directory) { |line| dict_words << line.chop }
dict_words
dict_words.count
@
c
data_filterd = data_hash["Dataset"].delete_if { |w| w if w.split.count > 1 }
c
dict_results = additinal_words_hash(dict_words.to_s, data_filterd)
dict_results
c
dict_words.count
name = File.basename(datafile, File.extname(datafile))
@
name
data_hash
c
name = File.basename(datafile, File.extname(datafile))
c
name = File.basename(datafile, File.extname(datafile))
c
name = File.basename(datafile, File.extname(datafile))
c
datafiles = data_directory(root)
c
datafiles = data_directory(root)
name = File.basename(datafile, File.extname(datafile))
c
name = File.basename(datafile, File.extname(datafile))
c
data_hash = JSON.parse(File.read(datafile))
c
directory
c
File.foreach(directory) { |line| dict_words << line.chop }
c
data_filterd = data_hash["Dataset"].delete_if { |w| w if w.split.count > 1 }
c
dict_results = additinal_words_hash(dict_words.to_s, data_filterd)
c
reorganise
reorganised
c
cc
c
reorganised
c
cc
c
cc
reorganised
final_directory = "/Users/shadowchaser/Code/Ruby/Projects/music/scripts/data_json/" + path_hierarchy.join("/")
c
final_directory = "/Users/shadowchaser/Code/Ruby/Projects/music/scripts/data_json/" + path_hierarchy.join("/")
c
final_directory = "/Users/shadowchaser/Code/Ruby/Projects/music/scripts/data_json/" + path_hierarchy.join("/")
datafile
path_hierarchy = datafile.split("data_json")[1].split("/")
c
File.basename(path_hierarchy[-1], File.extname(path_hierarchy[-1]))
ls
filename = File.basename(path_hierarchy[-1], File.extname(path_hierarchy[-1]))
@
path_hierarchy = datafile.split("data_json")[1].split("/")
filename = File.basename(path_hierarchy[-1], File.extname(path_hierarchy[-1])) 
filename = File.basename(path_hierarchy[-1], File.extname(path_hierarchy[-1]))
@
path_hierarchy = datafile.split("data_json")[1].split("/")
filename = File.basename(path_hierarchy[-1], File.extname(path_hierarchy[-1]))
c
path_hierarchy = datafile.split("data_json")[1].split("/")
c
final_directory = "/Users/shadowchaser/Code/Ruby/Projects/music/scripts/data_types/" + path_hierarchy.join("/")
"#{final_directory}/#{filename}.json"
filename
c
cc
c
@
c
arry
arry << [adjective, verb, adverb, noun]
aa = ["a", "b", "c", "d"]
aa.to_s.scan(/(a|b)/)
c
home = ENV["HOME"]
app_name = Rails.application.class.module_parent.to_s
root = "#{home}/Code/Ruby/Projects/#{app_name}/scripts/text-lyrics"
c
lyric_options = lyrics_directory(File.join(root, "text-lyrics"))
lyric_file = lyric_options[index.to_i]
lyric_options
lyric_options.each_with_index { |f, i| puts "#{blue(i)}) #{f.split(/\//)[-1]}" }
@2
@
file_with_ext = lyric_file.split(/\//)[-1]
c
artist_name = lyric_file.split(/\//)[-3]
c
data[:artist] = artist_name
data
@
album_name = lyric_file.split(/\//)[-2]
c
data[:album] = album_name
data[:album]
data
c
lines[:lines_count] = data[:lyrics].count
lines[:words_count] = data[:lyrics].join(" ").split.count
lines
 lines[:lines_count] = data[:lyrics].count
lines
c
words_array = line.split
line
index
words_per_line << words_array.count
c
Vulgar.all
Onomatopoeia.all
quit
aa = ["a", "b", "c", "d", "e"]
bb = ["a", "b", "e"]
aa - bb
@
ls
data
verb
adverb
noun
c
data
@
verb
adverb
noun
adjective.map! { |arry| [arry[0] + arry[1]] }
adjective.map! { |arry| [arry[0] + arry[1]] }.flatten
aa = adjective.map! { |arry| [arry[0] + arry[1]] }
@
aa = adjective.map! { |arry| [arry[0] + arry[1]] }
noun
noun.map! { |arry| [arry[0] + arry[1]] }
noun
aa = noun.map! { |arry| [arry[0] + arry[1]] }
@
noun
aa = noun.map! { |arry| [arry[0] + arry[1]] }
noun
noun.flatten
data
data - noun.flatten
hashy
c
hashy
c
hashy
@
key
hashy
c
hashy
c
hashy
c
hashy
aa = [1,2,3,4]
bb = [1,2,3]
aa - bb
aa
bb
hashy
c
hashy
c
hashy
hashy["Dataset"]
hashy["Dataset"].class
hashy["Dataset"] - word_category
word_category
hashy["Dataset"] - word_category
word_category
word_category.flatten
c
hashy
v
c
hashy
data.count
@
final_directory.merge(just_sentences)
just_sentences
@
just_sentences
final_directory.merge(just_sentences)
final_directory
@
just_sentences
reorganised.merge(just_sentences)
c
Actor.all
datafile
File.read(datafile)
JSON.parse(File.read(datafile))
aa = File.read(datafile)
aa
aa.split("\n")
aa
bb = aa.split("\n")
data_hash = JSON.parse(lines)
lines
File.read(datafile)
lines = File.read(datafile).split("\n")
data_hash = JSON.parse(lines)
 path_hierarchy
path_hierarchy
path_hierarchy.object_id
aa = path_hierarchy.dup
aa
aa.object_id
reorganised
c
reorganised
c
reorganised
c
reorganised
c
reorganised
c
reorganised
c
seed_path["path"] = path_hierarchy_for_seed
reorganised.merge(seed_path)
c
reorganised
c
reorganised
c
@
two = one.merge(just_sentences)
(hashy[:adjective] || []) << remaped.flatten
hashy
hashy[:adjective]
hashy[:adjective].flatten
hashy
hashy[:adjective] = hashy[:adjective].flatten
hashy
ActiveRecord::SchemaMigration.where().delete_all
quit
c
data_keys
c
@
first = data_hash["Path"][0] ||= ""
data_hash
@
c
@
token
@
c
@
data_hash
c
data_hash
c
data_hash
data_hash["Path"][0]
c
@
data_hash
token
token.camel_case.constantize
c
@
c
token
token.camel_case.constantize.ids.present?
token.camel_case
token.camel_case.constantize
c
@
c
data_file
@
c
data_hash
c
k
dataset
k
dataset
l
@
dataset
c
Painter.all
Painter.all,map {|a| a.delete }
Painter.all.map {|a| a.delete }
Painter.all
quit
c
cc
c
Painter.all
token
seed_path["Path"]
seed_path["Path"].pop
@
seed_path["Path"].push(token)
quit
uit
quit
Painter.all
@
home = ENV["HOME"]
c
 app_name = Rails.application.class.module_parent.to_s
c
root = "#{home}/Code/Ruby/Projects/#{app_name}/lib/data_json"
c
models = "#{home}/Code/Ruby/Projects/#{app_name}/app/models"
@
c
filepaths = sub_dir(root)
models
filepaths = sub_dir(root)
@
modelpaths = sub_dir(models)
l
@
c
models_trim = modelpaths.map { |f| File.basename(f, File.extname(f)) }
c
Actor.all
show-models
Vulgar.all
quit
Vulgar.all
quit
Vulgar.all
quit
Vulgar.all
quit
Citrus.all
quit
Citrus.all
quit
Citrus.all
quit
c
app_name = Rails.application.class.module_parent.to_s
c
datafiles
c
root
datafiles = data_directory(root)
c
root
root = ""
datafiles = data_directory(root)
root = "/Users/shadowchaser/Code/Ruby/Projects/Lyric/scripts/two-data-sets/data_json"
datafiles = data_directory(root)
c
datafiles.present?
 logger.error("Ln: #{__LINE__} of #{__FILE__}: There where no files found @ #{root}")
reorganised
c
reorganised
final_directory
aa = "string"
aa
quit
datasets = get_dataset_directory(data_directory)
data_directory
@
c
datasets
@
c
ls
filepath
data_struct
data
File.read(datafile)
File.read(datafile).split("\n")
@
File.read(datafile).split("\n")
token = File.basename(seed_path["Path"][-1], File.extname(seed_path["Path"][-1]))
@
seed_path
token = File.basename(seed_path["Path"][-1], File.extname(seed_path["Path"][-1]))
@
filename = path_hierarchy[-1]
File.basename(f,File.extname(f))
f = path_hierarchy[-1]
File.basename(f,File.extname(f))
path_hierarchy[-1]
file
no_extention = File.basename(file, File.extname(file))
filename = File.join("#{no_extention}", "json")
@
filename = "#{no_extention}" + ".json"
seed_path["Path"].class
seed_path["Path"] = path_hierarchy_for_seed
seed_path["Path"].class
a_a_s
c
line
line.split
c
@
word_records
@
found_term
word_records
quit
c
datafiles
quit
datafile.split("\\")
datafile.split("/")
datafile.split("/")[-1]
@
data_set.each { |w| (just_sentences["Sentences"] || []) << w if w.split.count > 1 }
c
just_sentences
ls
data_filterd
data_filterd.split.count
data_filterd.split.count > 1
data_filterd
ls
 data_set
c
data_filterd
just_sentences["Sentences"].present?
just_sentences
aa = {}
bb = {a: 1}
aa.merge(bb)
@
just_sentences
hash_with_path
@
path_hierarchy
path_hierarchy = datafile.split("data_txt")[1].split("/")
datafile
c
datafile
path_hierarchy
datafile
c
datafile
c
Poet.all
aa = "this-has_some+shit"
cheat
show-method String#tr
show-doc String#tr
find-method String#tr
find-method tr
cheat
cd String#tr
ls
?
show-source -d
up
show-source -d String#tr
nesting
ri Array
ri Array#tr
ri String#tr
quit
c
@
data
@
c
data
data.each { |word| word.tr("-_", " ") }
data << "my_stupid-string"
@
data.each { |word| word.tr("-_", " ") }
data.select { |word| word.tr("-_", " ") }
data.map { |word| word.tr("-_", " ") }
c
@
data
c
@
data
data.map { |word| word.tr("-_", " ") }
data_set
data_set << "my-bad_string"
@
data_set.map { |word| word.tr("-_", " ") }
aa = [1,2,3,4,5]
aa.map {|a| a.tr("_", " ") }
aa = ["this_one", "not this"]
aa.map {|a| a.tr("_", " ") }
aa
aa.map! {|a| a.tr("_", " ") }
aa
aa = ["this_one", "not this"]
aa.map! {|a| a.tr("_", " ") }
aa = ["this_one", "not this"]
aa = ["this one", "not this"]
aa.map! {|a| a.tr("_", " ") }
aa = "this is a voice that"
aa.scan(/\b#{ice t}\b/)
aa.scan(/\b"ice t"\b/)
aa = "this is a voice that ice t himself made"
aa.scan(/\b"ice t"\b/)
aa.scan(/\bice t\b/)
aa = {a: {b: 1}}
aa[:a]
aa[:a][:b]
quit
path_hierarchy_for_seed
path_hierarchy = datafile.split("data_txt/")[1].split("/")
c
@
path_hierarchy_for_seed = path_hierarchy.dup
C
c
file = path_hierarchy[-1]
c
@
filename = "#{file_name_no_ext}" + ".json"
c
path_hierarchy
c
path_hierarchy
@
final_directory = "#{home}/Code/Ruby/Projects/#{app_name}/scripts/data_json/" + path_hierarchy.join("/")
c
 seed_path = {}
c
path_hierarchy_for_seed
c
path_hierarchy_for_seed
token = File.basename(seed_path["Path"][-1], File.extname(seed_path["Path"][-1]))
file_name_no_ext
seed_path
path_hierarchy = datafile.split("data_txt/")[1].split("/")
nesting
step
file = path_hierarchy[-1]
step
filename = "#{file_name_no_ext}" + ".json"
step
nesting
next
path_hierarchy
path_hierarchy.pop
path_hierarchy
step
final_directory = "#{home}/Code/Ruby/Projects/#{app_name}/scripts/data_json/" + path_hierarchy.join("/")
quit
show-source Array#select
ri Array
ri Array#select
stat
?
Array ?
!
? Array
@
!
@
c
next
?
Array ?
l
ls
cd
!
? Array
? Array#include?
quit
c
ri Hash
quit
@
c
birds = ["Golden Eagle", "Gyrfalcon", "American Robin",
         "Mountain BlueBird", "Mountain-Hawk Eagle"]
grouped_by_first_letter = birds.group_by { |s| s[0] }
 birds.order_by {|a| a[0] }
birds = {bird: [eagle], mammal: [tiger]}
birds = {bird: ["eagle"], mammal: ["tiger"]}
birds.order_by {|a| a[0] }
cd Hash
ls
cd
birds.sort_by {|k, v| v}
birds.sort_by {|k, v| v}.to_h
birds.sort_by {|k, v| k}.to_h
birds = {1: ["eagle"], mammal: ["tiger"]}
birds = {"1": ["eagle"], "2": ["tiger"]}
birds.sort_by {|k, v| k}.to_h
birds = {"3": ["eagle"], "2": ["tiger"], "1": ["thing"]}
birds.sort_by {|k, v| k}.to_h
final_hash
quit
l
quit
Lotus.all
quit
Dacia.all
Dacium.all
quit
Kia.all
Lancia.all
Savoia.all
Douglas.all
ri Array

  &
  *
  +
  -
  <<
  <=>
  ==
  []
  []=
  abbrev
  all?
  any?
  append
  assoc
  at
  bsearch
  bsearch_index
  clear
  collect
  collect!
  combination
  compact
  compact!
  concat
  count
  cycle
  deconstruct
  delete
  delete_at
  delete_if
  difference
  dig
  drop
  drop_while
  each
  each_index
  empty?
  eql?
  fetch
  fill
  filter
  filter!
  find_index
  first
  flatten
  flatten!
  hash
  include?
  index
  initialize_copy
  insert
  inspect
  intersection
  join
  keep_if
  last
  length
  map
  map!
  max
  min
  minmax
  none?
  one?
  pack
  permutation
  pop
  prepend
  product
  push
  rassoc
  reject
  reject!
  repeated_combination
  repeated_permutation
  replace
  reverse
  reverse!
  reverse_each
  rindex
  rotate
  rotate!
  sample
  select
  select!
  shelljoin
  shift
  shuffle
  shuffle!
  size
  slice
  slice!
  sort
  sort!
  sort_by!
  sum
  take
  take_while
  to_a
  to_ary
  to_h
  to_s
  transpose
  union
  uniq
  uniq!
  unshift
  values_at
  zip
  |

(from gem activesupport-7.0.2.4)
------------------------------------------------------------------------











------------------------------------------------------------------------
Class methods:

  wrap

Instance methods:

  deep_dup
  excluding
  extract!
  extract_options!
  fifth
  forty_two
  fourth
  from
  in_groups
  in_groups_of
  including
  inquiry
  second
  second_to_last
  split
  third
  third_to_last
  to
  to_formatted_s
  to_fs
  to_param
  to_query
  to_sentence
  to_xml
  without

(from gem concurrent-ruby-1.1.10)
------------------------------------------------------------------------
@!macro concurrent_array
------------------------------------------------------------------------
(from gem msgpack-1.5.1)
------------------------------------------------------------------------
Instance methods:

  to_msgpack_with_packer

(from gem solargraphquit
aa = [1,2,3,4,5]
Artist.all
Masculine.all
quit
help ls
cd Array
-m
cd include
cd include?
ls
up
cd Array#include?
ls
show-method include?
cheat
? include?
show-source
nesting
0
quit
ls -m
cd Array
ls -m
ls
show-method empty?
? empty?
quit
Kias.all
quit
Kia.all
quit
Artist.all
Negative.all
quit
[{"pos":"n.","word":"A","definitions":["Of. [Obs.] \"The name of John a Gaunt.\" \"What time a day is it \" Shak. \"It's six a clock.\" B. Jonson."]}]
[{"pos":"n.","word":"A","definitions":["Of. [Obs.] \"The name of John a Gaunt.\" \"What time a day is it \" Shak. \"It's six a clock.\" B. Jonson."]}, {"pos":"n.","word":"A","definitions":["A barbarous corruption of have, of he, and sometimes of it and of they. \"So would I a done\" \"A brushes his hat.\" Shak."]}, ]
aa = [{"pos":"n.","word":"A","definitions":["Of. [Obs.] \"The name of John a Gaunt.\" \"What time a day is it \" Shak. \"It's six a clock.\" B. Jonson."]}, {"pos":"n.","word":"A","definitions":["A barbarous corruption of have, of he, and sometimes of it and of they. \"So would I a done\" \"A brushes his hat.\" Shak."]}, ]
aa
aa[0]
aa[0].class
aa[0]
aa
exit
aa = [{"pos":"n.","word":"A","definitions":["Of. [Obs.] \"The name of John a Gaunt.\" \"What time a day is it \" Shak. \"It's six a clock.\" B. Jonson."]}, {"pos":"n.","word":"A","definitions":["A barbarous corruption of have, of he, and sometimes of it and of they. \"So would I a done\" \"A brushes his hat.\" Shak."]}, ]
aa
aa[0]
aa[0][:pos]
dictionary_hash
!
Dictionary.all.count
Dictionary.all
Dictionary.all.map {|a| a.destroy }
exit
dict
Dictionary.all
Dictionary
dict[:pos]
@
dict.class
dict
up
dictionary_hash.deep_symbolize
aa = [{"pos":"n.","word":"A","definitions":["Of. [Obs.] \"The name of John a Gaunt.\" \"What time a day is it \" Shak. \"It's six a clock.\" B. Jonson."]}, {"pos":"n.","word":"A","definitions":["A barbarous corruption of have, of he, and sometimes of it and of they. \"So would I a done\" \"A brushes his hat.\" Shak."]}, ]
pry-theme try solarized
aa = [{"pos":"n.","word":"A","definitions":["Of. [Obs.] \"The name of John a Gaunt.\" \"What time a day is it \" Shak. \"It's six a clock.\" B. Jonson."]}, {"pos":"n.","word":"A","definitions":["A barbarous corruption of have, of he, and sometimes of it and of they. \"So would I a done\" \"A brushes his hat.\" Shak."]}, ]
aa[:word]
aa[0][:word]
ri Array
exit
Dictionary.count
exit
Dictionary.all.count
exit
Dictionary.all.count
exit
Dictionary.all.first
Dictionary.all.pluck(:wprd_type).uniq
Dictionary.all.pluck(:word_type).uniq
Dictionary.where(word: datafile)
datafile
@
Dictionary.where(word: dataset)
dataset
dataset.delete_if { |word| word.split.count > 1 }
dataset.present?
records = Dictionary.where(word: dataset)
next
dataset
c
dataset
c
dataset
c
dataset
@
c
records = Dictionary.where(word: dataset)
records
Dictionary.first
quit
Dictionary.all.map {|word| word.downcase }
cd Array
ls
cd
cd String
ls
cd
@
Dictionary.all.map {|record| record[:word].downcase }
l
Dictionary.all.first
Dictionary.all.map {|record| record[:word_type].tr("\.", "") }
l
Dictionary.all.first
Dictionary.all.map! {|record| record[:word_type].tr("\.", "") }
Dictionary.all.map {|record| record[:word_type].tr("\.", "") }
Dictionary.all
Dictionary.all.first
Dictionary.all.map! {|record| record[:word].downcase }
Dictionary.all.map {|record| record[:word].downcase }
Dictionary.all
Dictionary.all.first
Dictionary.first
Dictionary.first.attributes
Dictionary.all.pluck(:word_type).uniq
Dictionary.all.first
@
attributes
attributes.update.word_type("\.", "")
@
attributes.update.word_type.tr("\.", "")
attributes.update.word_type
attributes.word_type
attributes.word_type.update = attributes.word_type.downcase
attributes.word_type = attributes.word_type.downcase
attributes.update(word_type: attributes.word_type.downcase)
Dictionary.all.pluck(:word_type).uniq
@
attributes.update(word: attributes.word.downcase)
attributes
attributes.word_type
Dictionary.all.pluck(:word_type).uniq
Dictionary.all.find_by(word_type: :"a.")
Dictionary.all.find_by(word_type: :"a.").count
Dictionary.all.where(word_type: :"a.")
Dictionary.all.where(word_type: :"a.").count
Dictionary.all.pluck(:word_type).uniq
Dictionary.all.first
Dictionary.all.pluck(:word.:word_type).to_h
Dictionary.all.pluck(:word,:word_type).to_h
fg
exit
quit
bad_words
bad_words.count
@
result
c
ls
result
@
data_hash
c
dictionary_hash
data_hash.count
ls
dictionary_hash.count
dictionary_hash.last
@
c
key
value
Dictionary
Dictionary.find_or_create_by(word: key, word_type: value)
Dictionary.all.count
Dictionary.last
quit
l
@
Dictionary.where(word: )
aa = ["that", "is", "currie"]
Dictionary.where(word: aa)
aa = Dictionary.where(word: aa)
aa.count
aa.group_by {|a| a[:word_type] }
 reorganised = Dictionary.where(word: data_filterd)
data_filterd
c
Dictionary.where(word: data_filterd)
reorganised = Dictionary.where(word: data_filterd)
c
reorganised = Dictionary.where(word: data_filterd)
reorganised = Dictionary.where(word: data_filterd).group_by {|record| record[:word_type] }
reorganised = Dictionary.where(word: data_filterd).group_by {|record| record[:word_type] }.pluck(:word, :word_type)
reorganised = Dictionary.where(word: data_filterd).group_by {|record| record[:word_type] }
reorganised = Dictionary.where(word: data_filterd).pluck(:word, :word_type)
reorganised = Dictionary.where(word: data_filterd).pluck(:word, :word_type).group_by {|record| record[:word_type] }
reorganised = Dictionary.where(word: data_filterd).pluck(:word, :word_type).group_by {|record| record[1] }
reorganised = Dictionary.where(word: data_filterd).pluck(:word, :word_type).group_by {|record| record[1] }.flatten
reorganised = Dictionary.where(word: data_filterd).pluck(:word, :word_type).group_by {|record| record[1] }
cd group_by
ri group_by
cd
reorganised = Dictionary.where(word: data_filterd).pluck(:word, :word_type).group_by {|record| record[1].pop }
reorganised = Dictionary.where(word: data_filterd).pluck(:word, :word_type).group_by {|record| record[1].delete }
c
reorganised = Dictionary.where(word: data_filterd)
c
reorganised = Dictionary.where(word: data_filterd)
reorganised = Dictionary.where(word: data_filterd).class
reorganised = Dictionary.where(word: data_filterd).group_by {|record| record[:word_type] }
reorganised["noun"]
reorganised["noun"].pluck(:word)
c
reorganised
c
reorganised
reorganised = Dictionary.where(word: data_filterd).group_by { |record| record[:word_type] }
reorganised.keys.each { |records| reorganised[records] = reorganised[records].pluck(:word) }
reorganised
c
reorganised
c
reorganised
ls
data_filterd
c
reorganised.keys.each { |records| reorganised[records] = reorganised[records].pluck(:word) }
c
reorganised.keys.each { |records| reorganised[records] = reorganised[records].pluck(:word) }
reorganised
c
reorganised.keys.each { |records| reorganised[records] = reorganised[records].pluck(:word) }
c
reorganised.keys.each { |records| reorganised[records] = reorganised[records].pluck(:word) }
c
reorganised.keys.each { |records| reorganised[records] = reorganised[records].pluck(:word) }
reorganised
data_filterd
reorganised = Dictionary.where(word: data_filterd)
reorganised = Dictionary.where(word: data_filterd).group_by { |record| record[:word_type] }
@
reorganised.keys.each { |records| reorganised[records] = reorganised[records].pluck(:word) }
reorganised
@
reorganised = Dictionary.where(word: data_filterd).group_by { |record| record[:word_type] }
reorganised.class
step
next
step
nesting
step
next
reorganised.keys.each { |records| reorganised[records] = reorganised[records].pluck(:word) }
reorganised
Dictionary.find_by(word: ;wiccan)
Dictionary.find_by(word: :wiccan)
Dictionary.find_by(word: :wicca)
Dictionary.create(word: :wicca, word_type: :noun)
Dictionary.find_by(word: :kabbalah)
Dictionary.find_by(word: :Kabbalah)
Dictionary.find_or_create_by(word: :kabbalah)
Dictionary.find_by(word: :Kabbalah)
Dictionary.last
Dictionary.find_by(word: :kabbalah)
Dictionary.last.update(word_type: :noun)
Dictionary.find_by(word: :kabbalah)
Dictionary.find_or_create_by(word: :theosophist, word_type: :noun)
Dictionary.find_or_create_by(word: :rosicrucian, word_type: :noun)
Dictionary.find_or_create_by(word: :rosicrucian, word_type: :adjective)
Dictionary.find_or_create_by(word: :theosophist, word_type: :noun)
Dictionary.find_or_create_by(word: :marcionism, word_type: :noun)
l
@
up
step
reorganised.keys.each { |records| reorganised[records] = reorganised[records].pluck(:word) }
c
reorganised.keys.each { |records| reorganised[records] = reorganised[records].pluck(:word) }
c
reorganised.keys.each { |records| reorganised[records] = reorganised[records].pluck(:word) }
reorganised
data_filterd
Dictionary.find_by(word: :wiccan)
c
@
key
value
c
data_filterd
data_filterd.count
@
value
value.count
remainder = data_filterd - value
remainder
remainder = value - data_filterd
l
@
data_filterd - value
reorganised["Words"] << remainder if remainder.present?
reorganised["Words"]
remainder.present?
remainder
remainder = data_filterd - value
@
reorganised["Words"] << remainder if remainder.present?
reorganised["Word"] << remainder if remainder.present?
aa = [[1,2,3,4,5][1]]
aa = [[1,2,3,4,5],[1]]
aa.flatten
c
reorganised
@
reorganised
c
just_sentences
reorganised
c
@
reorganised
data_filterd
ls
just_sentences
@
just_sentences
 reorganised.merge(just_sentences)\
 reorganised.merge(just_sentences)
!
 reorganised.merge(just_sentences)
reorganised
result_with_sentences = reorganised.merge(just_sentences)
result_with_sentences
@
data_filterd
c
@
 reorganised
reorganised
@
reorganised
@
reorganised.present?
data_filterd.present?
data_filterd
reorganised
data_filterd
@
c
reorganised
c
result_with_sentences
ls
data_set
datafile
datafiles
@
ls
data_set
data_filterd
app_name
up
datafile
c
datafile
data_file
l
sls
ls
datafile
data_set
c
result_with_sentences
reorganised
result_with_sentences = reorganised.merge(just_sentences)
data_set
ls
data_set
datafile
datafiles
@
c
remainder = reorganised["words"] - value
reorganised["words"]
reorganised["Words"]
@
data_filterd
reorganised["words"]
reorganised["Words"] = data_filterd
@
value
key
aa = ["a", "b"]
bb = ["a"]
aa = bb
aa = ["a", "b"]
bb = ["a"]
aa - bb
@
remainder = reorganised["Words"] - value
value
Dictionary.all.count
quit
Artist.all
quit
ls
sentiment_hash
success
word_records
c
ls
success
word_records
sentiment_hash
@
 remove_unwanted_models
cached_models
@
step
aa = [{name: :madonna, year: 1980}]
aa[0]
aa[0].name
aa[0].class
aa[0][:name]
list_symbols
symbols
Symbol.all_symbols
exit
result
result.keys
reult
result
c
aa = {year: 1990, genre: "rocky"}
aa.values
c
Daw.all
quit
Jean.all
Jeans.all
Knot.all
Knots.all
MaleSuperHeroe.all
MaleSuperheroe.all
FemaleSuperheroe.all
quit
MaleSuperheroe.all
quit
Knot.all
Knots.all
quit
MaleSuperheroe.all
quit
Knot.all
quit
Digestive.all
DigestiveSystem.all
quit
Bra.all
quit
cheat
? String#ord
quit
ri String#ord
quit
Dictionary.all.coount
Dictionary.all.count
quit
Dictionary.all.count
quit
Dictionary.all.count
quit
show-models
quit
help show-doc
up
? String#ord
quit
SmallStar.all
quit
show-models
Dictionary.all
Dictionary.all.count
class String

  def permutation(&block)
    arr = split(//)
    arr.permutation { |i| yield i.join }
  end
end


wordlist = ["one", "two"]

"noe".permutation do |i|
  puts "match found: #{i}" if wordlist.include?(i)
end
quit
def words chars, result='', &b
  if chars.empty?
    yield result
  else
    chars.length.times do |i|
      c = (x = chars.clone).slice!(i)
      words(x, result + c, &b)
    end
  end
end
def words(topgun)
!!
!
 def words(chars, result='', &b)
if chars.empty?
    yield result
  else
    chars.length.times do |i|
      c = (x = chars.clone).slice!(i)
      words(x, result + c, &b)
    end
  end
end
def words(topgun)
end
def combine_anagrams(words)
  cp = 0
  hash = Hash.new []
  words.each do |word|
    cp += 1
    (cp..words.count).each do |i|
      hash[word.to_s.chars.sort.join] += [word]
    end
    hash[word.to_s.chars.sort.join] = hash[word.to_s.chars.sort.join].uniq
  end
  return hash
end
def combine_anagrams(long)
!
words(topgun)
def words(chars, result='', &b)
if chars.empty?
    yield result
  else
    chars.length.times do |i|
      c = (x = chars.clone).slice!(i)
      words(x, result + c, &b)
    end
  end
end
words(topgun)
words("t", "o", "p")
def words chars, result='', &b
  if chars.empty?
    yield result
  else
    chars.length.times do |i|
      c = (x = chars.clone).slice!(i)
      words(x, result + c, &b)
    end
  end
end
words("topgun")
 def words(chars, result='', &block)
  if chars.empty?
    yield result
  else
    chars.length.times do |i|
      c = (x = chars.clone).slice!(i)
      words(x, result + c, &b)
    end
  end
end
words(topgun)
words("topgun")
def combine_anagrams(words)
  cp = 0
  hash = Hash.new []
  words.each do |word|
    cp += 1
    (cp..words.count).each do |i|
      hash[word.to_s.chars.sort.join] += [word]
    end
    hash[word.to_s.chars.sort.join] = hash[word.to_s.chars.sort.join].uniq
  end
  return hash
end
combine_anagrams(topgun)
combine_anagrams("topgun")
combine_anagrams(["topgun", "batty crease"])
def combine_anagrams(words)
  output_array = Array.new(0)
  words.each do |w1|
    temp_array = []
    words.each do |w2|
      if (w2.downcase.split(//).sort == w1.downcase.split(//).sort)
        temp_array.push(w2)
      end
    end
    output_array.push(temp_array)
  end
  return output_array.uniq
end
combine_anagrams(["topgun", "bunhole",])
combine_anagrams(["look"])
combine_anagrams(["thinker"])
combine_anagrams(["cat"])
words(["cat"])
words(cat)
class String

  def permutation(&block)
    arr = split(//)
    arr.permutation { |i| yield i.join }
  end
end
permutation(topgun)
permutation(["topgun"])
topgun.permutation
"topgun".permutation
wordlist = ["one", "two"]

"noe".permutation do |i|
  puts "match found: #{i}" if wordlist.include?(i)
end
"cat".permutation do |i|
  puts "match found: #{i}" if wordlist.include?(i)
end
quit
words = ["cat", "dog"]
@words_hash = words.each_with_object(Hash.new []) do |word, hash|
  hash[word.chars.sort] += [word]
end
@words_hash = words.group_by {|word| word.chars.sort}; @words_hash.default = []
@words_hash = words.group_by {|word| word.chars.sort}
"test".chars
"test".chars.sort
pry
quit
exit
test_words = ['cars', 'for', 'potatoes', 'racs', 'four', 'scar', 'creams', 'scream']
test_words.group_by{|w| w.each_char.sort}.values
test_words = ['the', 'them', 'there']
test_words.group_by{|w| w.each_char.sort}.values
test_words.group_by{|w| w.downcase.each_char.sort}.values.each{|v| v.uniq!}
quit
words = ['alt', 'altfor', 'andre', 'at', 'bar', 'bra', 'bry', 'byr', 'dem', 
'den', 'denne', 'dra', 'drev', 'drikke', 'dro', 'ende', 'enden', 'engang',
'ens',  'etter',  'gangen', 'gift', 'gikk', 'gilde', 'hellestein', 'hun', 'hus',
'kisten', 'krok', 'lovt', 'lysnet',  'lysten', 'løst', 'med', 'mor', 'navn',
'ned', 'nede', 'niste', 'ord', 'ordet', 'rad', 'rette', 'ristet', 'rod', 'rokk',
'rom', 'rå', 'sen', 'sitter', 'skinte', 'steinhelle', 'stien', 'stuen', 'støl',
'suten', 'søsteren', 'søstrene', 'ta', 'tolv', 'torde', 'truet', 'turte',
'vann', 'år']
# Anagrams are equal when all characters are sorted
words_hash = words.each_with_object(Hash.new []) do |word, hash|
  hash[word.chars.sort] += [word]
end
words_hash.each do |word, matching_words|
  puts matching_words.join ', ' if matching_words.length > 1
end
Dictionary.all.count
quit
Dictionary.all.count
@words_hash = Dictionary.each_with_object(Hash.new []) do |word, hash|
  hash[word.chars.sort] += [word]
end
@words_hash = Dictionary.all.each_with_object(Hash.new []) do |word, hash|
  hash[word.chars.sort] += [word]
@words_hash
Dictionary.all.count
!!!
Dictionary.all
@words_hash = Dictionary.all.each_with_object(Hash.new []) do |word, hash|
  hash[word.chars.sort] += [word]
hash
@words_hash = Dictionary.all.each_with_object(Hash.new []) do |word, hashy|
  hashy[word.chars.sort] += [word]
@words_hash.count
!
@words_hash = Dictionary.all.each_with_object(Hash.new []) do |word, hashy|
  hashy[word.chars.sort] += [word]
help
? String:chars
cd String
ls
up
String:chars ?
ls
!
show-doc String:chars
ri String:chars
quit
? String:chars
? String#chars
quit
Toxicity.all
 LowToxicity.all
Chord.all
quit
Chord.all
Chord.all.map {|obj| obj.word.downcase }
Chord.all.map {|obj| obj.word-type.downcase }
Chord.all.map {|obj| obj.word_type.downcase }
l
Chord.all
Chord.all.map {|obj| obj.update.word.downcase }
Chord.all.map {|obj| obj.word.update.downcase }
Chord.all.map {|obj| obj.word.downcase.update }
Chord.all.map! {|obj| obj.word.downcase }
Chord.all.map {|obj| obj.word.update.downcase }.update
Chord.all {|obj| obj.word.downcase }
Chord.all {|obj| obj.word.downcase.update }
Chord.all {|obj| a = obj.update; a.word.downcase }
Chord.all {|obj| a = obj.word.downcase; a.update }
Chord.first
Chord.first.word
Chord.first.word.downcase
a = Chord.first.word.downcase
a
a.update
a = Chord.first
a.word
a.word.downcase
a.word.downcase.update
b = a.word.downcase
bb = a.word.downcase
bb.update
Chord.first.word.downcase
l
quit
History
H
cheat
history
quit
history
history -1000
quit
Chord.first
Chord.all {|obj| a = obj; a.word.downcase; a.update }
Chord.all {|obj| a = obj; a.word.downcase}
l
Chord.all {|obj| a = obj; a.word.downcase!}
Chord.all {|obj| a = obj; a.word.downcase!; a.update}
quit
Chord.all
quit
Chord.all
quit
words = ["rapper", "hiphop"]
@words_hash = words.each_with_object(Hash.new []) do |word, hash|
  hash[word.chars.sort] += [word]
end
quit
class String

  def permutation(&block)
    arr = split(//)
    arr.permutation { |i| puts "#{yield i.join}" }
  end
end


wordlist = ["one", "two"]

"noe".permutation do |i|
  puts "match found: #{i}" if wordlist.include?(i)
end
class String

  def permutation(&block)
    arr = split(//)
    arr.permutation.each do |i| yield i.join end
end


wordlist = ["one", "two"]

"noe".permutation do |i|
  puts "match found: #{i}" if wordlist.include?(i)
end
!
class String

  def permutation(&block)
    arr = split(//)
    arr.permutation.each do |i| yield i.join 
  end
end


wordlist = ["one", "two"]

"noe".permutation do |i|
  puts "match found: #{i}" if wordlist.include?(i)
end
!
class String
def permutation(&block)
arr = split(//)
arr.permutation.each do |i|
pry.binding
yield i.join
end
wordlist = ["one", "two"]
"noe".permutation do |i|
  puts "match found: #{i}" if wordlist.include?(i)
end
!
quit
i
yield i.join
i.join
c
i
c
i
arr
quit
"The".chars
"The".chars.sort
"eht".chars
"eht".chars.sort
? String#sort
? String#Sort
cd string
cd String
l
ls
cd
? Chars#sort
cd sort
cd Chars
? String#chars
cd String 
ls
cd
? Array#sort
quit
cd rand
l
ls
cd
? Rand
Int#rand
quit
c
stack
c
stack
c
length
stack
c
stack
c
stack
c
stack
length
c
l
quit
stack
quit
aa = [1,1,1]
aa[-3]
aa = [1,2,1,1,1]
aa[-3..-1]
aa[-4..-1]
quit
aa = [1,2,3,4]
aa.sum
aa[-2..-1]
aa[-2..-1].sum
stack
stack[-3..-1]
c
cc
c
stack.size
stack[-3..-1].sum
stack[-3..-1].sum == 3
c
stack[-3..-1].sum == 3
cstack[-3..-1].sum
stack[-3..-1].sum
c
stack[-3..-1].sum
c
stack[-3..-1].sum
stack[-3..-1].sum == 3
c
l
quit
aa = [1,2,3,4]
aa[-1]
aa[-3..-1]
quit
occupied = 1
while occupied != 1
puts busy
end
quit
Greyscale.all
quit
@
lines[:syllables]
lines[:percentages]
@
lines[:percentages]
c
MidToxicity.all
MidToxicity.find_by(name: :pink)
MidToxicity.all.find_by(name: :pink)
MidToxicity.all
MidToxicity.all.find_by(name: :pink)
MidToxicity.all.find_by(word: :pink)
MidToxicity.all.find_by(word: :pink).delete
cheat
HT
MidToxicity.all.find_by(word: :pink)
quit
aa = 1.22222222
aa.round(3)
aa = 1.1
aa.round(3)
quit
c
BrightStar.all
quit
c
Currency.all
CurrencyType.find_by(name: :word)
CurrencyType.find_by(word: and)
CurrencyType.find_by(word: :and)
CurrencyType.find_by(word: :and).delete
quit
aa = ["this", "is", "a", "movie"]
aa[1]
aa[0]..aa[4]
aa[0]..[4]
aa.to_s.scan(/forest gump/)
aa.push("forest gump")
aa.to_s.scan(/forest gump/)
aa.to_s
aa = ["forest", "gump"]
aa.to_s.scan(/forest gump/)
aa.to_s.chomp
aa.join
aa.join(" ")
aa.join(" ").scan(/forest gump/)
quit
HT
aa = ["forest", "gump"]
aa.join(" ").scan(/["forest gump", "forest"]/)
aa.join(" ").scan(/forest gump/)
aa.join(" ")
aa = ["this", "is", "a", "movie", "about", "forest", "gump"]
aa.join(" ").scan(/forest gump/)
quit
data
data.join
data.join(" ")
data.join(" ").compact
data[:lyrics]
data[:script].join
data[:scripts].join
data[:lyrics].join
data[:lyrics].join.(" ")
data[:lyrics].join
data[:lyrics].join.split(" ")
HT
data[:lyrics].join.split(" ").to_s
;HT
HT
data[:lyrics].join.split(" ").to_s.scan(/forest gump/)
data[:lyrics] << "forest"
HT
data[:lyrics] << "gump"
HT
data[:lyrics].join.split(" ").to_s
data[:lyrics] << "forest gump"
HT
data[:lyrics].join.split(" ").to_s.scan(/forest gump/)
data[:lyrics].join.split(" ").to_s
data[:lyrics].join.split(" ").join(" ").scan(/forest gump/)
data[:lyrics].join.split(" ").join(" ").scan(/my names/)
data[:lyrics].join.split(" ").join(" ").scan(/chocalate/)
data[:lyrics].join.split(" ").join(" ")
HT
data[:lyrics].join.split(" ").join(" ").scan(/a big pile of dogshit/)
data[:lyrics].join.split(" ").join(" ").scan(/it/)
data[:lyrics].join.split(" ").join(" ").scan(/gump/)
data[:lyrics].join.split(" ").join(" ").scan(/forest gump/)
data[:lyrics].join.split(" ").join(" ").scan(/Forest gump/)
data[:lyrics].join.split(" ").join(" ").scan(/Forest Gump/)
data[:lyrics].join.split(" ").join(" ").scan(/forrest gump/)
HT
data[:lyrics].join.split(" ").join(" ").scan(/forrest gump/).count
data[:lyrics].join.split(" ").join(" ").scan(/forrest gump/)
quit
HT
data[:lyrics].join.split(" ").join(" ").scan(/forrest gump/)
data[:lyrics].join.split(" ").join(" ").scan(/forrest gump/).count
c
@
data[:lyrics]
@
data[:lyrics].join.split(" ").join(" ")
result[:forest_gump] = data[:lyrics].join.split(" ").join(" ").scan(/forrest gump/).count
result
quit
Film.all.count
Film.all
quit
HT
Film.all
quit
Film.all.count
movie
movie.name
c
HT
Data
data
HT -100
HT 100
data[:lyrics].join.split(" ").join(" ").scan(/forest gump/)
data[:script]
HT 100
data[:script].join.split(" ").join(" ").scan(/forrest gump/)
c
Film.all.find_by(name: :"forrest gump")
Film.all
quit
movie
data[:script].join.split(" ").join(" ").scan(/"#{movie.name}"/)
c
data[:script].join.split(" ").join(" ").scan(/"#{movie.name}"/).present?
data[:script].join.split(" ").join(" ").scan(/"#{movie.name}"/)
data
HT 100
data[:lyrics].join.split(" ").join(" ").scan(/forrest gump/)
data[:script].join.split(" ").join(" ").scan(/forrest gump/)
data[:script].join.split(" ").join(" ")
HT
data[:script].join.split(" ").join(" ").scan(/forrest gump/)
@
movie_script = data[:script].join.split(" ").join(" ")
@
Film.all
@
c
Film.all.find_by(name: :they)
Film.all.find_by(name: :they).delete
l
quit
ls
movie_list
lyric_file
lyric_file[-1]
c
filename = lyric_file.split(/\//)[-1]
c
ls
file_name_json
movie_script = data[:script].join.split(" ").join(" ")
movie_script.class
c
Film.all.count
quit
c
Film.all.find_by(name: :woods)
HT
HT 100
data[:script].join.split(" ").join(" ")
quit
Film.all.find_by(name: :"a room with a view")
quiit
quit
Wisconsin.all
quit
c
Kansas.all
quit
Kansa.all
quit
Kansa.all
quit
"test"
aa = "test"
aa.chars
aa = "nut"
aa.chars
aa.include?(tun)
aa.include?("tun")
bb = "tun"
bb.chars
aa.chars.include?(bb.chars)
aa.chars.sort
aa.normalize
aa.chars.normalize
cd Array#normalize
ls
cd
aa = "thisisalongword"
aa.to_s.scan(/[a-z]/)
used_letters = Array.new(256, nil)
query_letters_sorted = ["t", "e", "s", "t"]
query_letters_sorted.sort
query_letters_sorted.sort.each do |letter|
    used_letters[letter] = true
end
query_letters_sorted = ["t", "e", "s", "t"].sort
query_letters_sorted.each do |letter|
    used_letters[letter] = true
end
used_letters
used_letters[a[1]]
aa
query_letters_sorted[0]
query_letters_sorted[1]
quit
“abcdefg”.split(//).sort_by{rand}.join
"abcdefg".split(//).sort_by{rand}.join
hashy = {}
count = 0
while count == 0
word = "abcdefg".split(//).sort_by{rand}.join
unless hashy.key?(name)
hashy[name] = name.count
end
while count == 0
 word = "abcdefg".split(//).sort_by{rand}.join
unless hashy.key?(word)
hashy[word] = word.count
end
c
hashy
c
aa = W{t u n}
aa = w{t u n}
aa = ["t", "u", "n"]
aa.combination(3)
aa.combination(3).to_a
 aa.combination(1)
aa.combination(1).to_a
 aa.combination(2).to_a
aa.combination(3).to_a
aa = [1, 2, 3, 4]
aa.combination(3).to_a
quit
aa = swap("tun")
aa.combinations(3)
aa.combination(3)
aa.combination(3).to_a
aa.combination(1).to_a
aa.combination(2).to_a
aa.combination(4).to_a
aa.combination(3).to_a
@
aa = swap("tun")
aa.permutation.to_a 
aa = "tun".chars
aa.permutation.to_a
aa.permutation.to_h
aa.permutation.to_a.flatten
aa.permutation.to_a.group_by
bb = aa.permutation.to_a.group_by
bb
bb.count
aa.permutation.to_a.group_by {|i,a| i}
aa.permutation.to_a.group_by {|i| i.join }
aa.permutation.to_a.group_by {|i,a| a }
aa.permutation.to_a.group_by {|i| i.join }
bb = aa.permutation.to_a.group_by {|i| i.join }
bb
bb.map {|k,v| v.flatten }
bb
aa.permutation.to_a.group_by {|i| i.join }
Dictionary.all.pluck(:word)
@
Dictionary.all.pluck(:word).join(" ")
@
aa = Dictionary.all.pluck(:word).join(" ")
@
result.keys
result.scan(/nut/)
ls
dict.scan(/nut/)
@
.scan(/\bnut\b/)
dict.scan(/\b#{Regexp.quote(nut)}\b/)
dict.scan(/\b#{Regexp.quote("nut")}\b/)
Dictionary.all.find_by(name: :nut)
Dictionary.all.find_by(word: :nut)
@
dict.scan(/\b#{Regexp.quote(k)}\b/)
Dictionary.all.find_by(word: :tun)
:q
quit
c
anagram(word)
anagram(word).keys
quit
dictionary_lookup(anagram(word).keys)
anagram(word).keys
quit
term
@
term.class
Dictionary.all.where(word: term)
term = ["another", "found"]
Dictionary.all.where(word: term)
quit
result.count
result
result.present?
result
result if result.present?
result
cd String
ls
word = "time".chars
result = dictionary_lookup(word.anagram.keys)
word.anagram
word.class == Array
word.class
word.class == String
three_letter_words = dictionary_lookup(anagram(word).keys, 3)
three_letter_words = dictionary_lookup(anagram(word, 3).keys)
primary.class
primary.to_h
primary.merge(secondary)
secondary = dictionary_lookup(anagram(word, 3).keys)
primary.merge(secondary)
primary
primary.merge(secondary)
aa = primary + secondary
aa
word_length
word
@
k
v
result.keys
? Array#reverse
quit
diction
qit
diction
c
Dictionary.first
l
quit
Dictionary.all.count
quit
Dictionary.all.count
quit
Film.all.count
m
m.split("\t")
quit
c
m.split("\t")
m[8].to_a
m
m.split("\t")
c
 m.split("\t")
c
m.split("\t")
quit
Imdb.all.count
quit
Imdb.all.count
HR
Imdb.all.count
quit
Imdb.all.count
quit
Imdb.all.count
quit
Imdb.all
Imdb.all.count
show-models
Imdb.all.find_by(primary_title: :"the silence of the lambs")
Imdb.all.find_by(primary_title: :"The Silence of the Lambs")
quit
Imfb.all.first
Imdb.all.first
Imdb.all.find(2)
Imdb.all.find(3)
Imdb.all.find(5)
Imdb.all.find(7)
quit
m
m.split("\t")
m[0]
m.split("\t").downcase
attr
Imdb.first
Imdb.find(2)
quit
Imdb.all.count
quit
Imdb.all.count
quit
Imdb.all.count
quit
Imdb.all.count
Dictionary.all
Dictionary.all.count
quit
Imdb.all.count
quit
 movie_results = movie_script.scan(/\b#{Regexp.quote(movie.name)}\b/)
show-model
show-models
quit
 movie_results = movie_script.scan(/\b#{Regexp.quote(movie.primary_title)}\b/)
movie_results
movie_results.present?
c
cc
c
movie_results.present?
movie_results
movie_results.count
logger.info("Movie: #{movie.primary_title} found: #{result[movie.primary_title]} ")
result
@
aa = result.sort_by { |k, v| k }
aa = result.sort_by { |k, v| k if k.class == Integer }
aa = result.sort_by { |k, v| k if k.class == "Integer" }
@
ls
up
result.keys
result.sort_by { |k, v| k }
@
result.group_by
@
result.group_by {|k,v| v }
HT
result.group_by {|k,v| v }.sort
result.group_by {|k,v| v }.sort.to_h
HT
result.group_by {|k,v| v.to_h }.sort.to_h
result.group_by {|k,v| [k,v].to_h }.sort.to_h
result.group_by {|k,v| [k,v].to_h }.sort
result.group_by {|k,v| [k,v].to_h }
@
result.sort
result.sort.to_h
@
result.sort(:last)
result.sort_by(&:last)
HT
result.sort_by(&:last).to_h
HT
result.sort_by(&:first).to_h
HT
result.sort_by(&:last).to_h.reverse
HT
result.sort_by(&:last).to_h.reverse_each
HT
aa = {"two word": 1, "one": 1}
aa.sort_by(&:count)
aa[aa = {two word: 1, one: 1, three words here: 1}
aa = {two word: 1, one: 1, three words here: 1}
aa = {"two word": 1, "one": 1, "three words here": 1}
aa = {"two word": 1, "one": 1, "three words here": 3}
aa.keys = {"two word": 1, "one": 1, "three words here": 3}
aa = {"two word": 1, "one": 1, "three words here": 3}
aa.keys.sort_by(&:count)
aa.sort_by {|k,v| k.count }
aa = {"two word" => 1, "one" => 1, "three words here" => 3}
aa.sort_by {|k,v| k.count }
aa.sort_by {|k,v| k.split.count }
aa.sort_by {|k,v| k.split.count }.to_h
result.keys.sort_by(&:count).to_h.reverse_each
result.sort_by { |k, v| k.split.count }.to_h
@
result.each { |k, v| organised_result[k.split.count][k] = v }
result
@
result.each { |k, v| organised_result[k.split.count][k] = v }
@
organised_result
@
organised_result.sort_by {|k,v| v.sort_by(&:count).to_h } 
organised_result.sort_by {|k,v| v.sort_by(&:count)}
@
organised_result[k.split.count][k] = v }
organised_result
@
ls
result
result.sort_by {|k,v| k }
HT
result.sort_by {|k,v| k }.toh
result.sort_by {|k,v| k }.to_h
result.each {|k,v| v.sort_by(&:last) }
HT
result.sort_by {|k,v| v.sort_by(&:last) }
HT
result.sort_by {|k,v| k }
result.sort_by {|k,v| k }.to_h
c
show-models
Imdb.all.find_by(primary_title: :"a room with a view")
quit
Imdb.all.first
aa = {"1" => {"rambo" => 1, "rambo two" => 2} }
aa[1]
aa["1"]
aa.sort_by {|k,v| v }
aa = {"1" => {"rambo" => 1, "rambo two" => 2} "2" => {"comando" => 2}}
aa = {"1" => {"rambo" => 1, "rambo two" => 2}, "2" => {"comando" => 2}}
aa.each {|k,v| puts v }
aa.each {|k,v| puts k }
quit
Imdb.all.first
Imdb.all,find_by(primary_title: :"the silence of the lambs")
Imdb.all.find_by(primary_title: :"the silence of the lambs")
k
v
@
v.count
show-models
quit
@
orderd_data
ls
order_data
order_data.group
order_data.group_by
order_data.group_by.to_h
@
order_data
ls
data_order
@
data_order
data_order.each {|k, v| v.group_by.to_h }
data_order.each {|k,v| puts v }
HT
data_order.map {|k,v| v.group_by.to_h }
HT
data_order.map {|k,v| v.group_by.to_h }.sort
aa = data_order.map {|k,v| v.group_by.to_h }
aa.sort
aa
data_order
 data_order.group_by { |k, v| v }
 data_order.group_by { |k, v| v }.to_h
result[title_count].group_by { |k, v| v }.to_h
result.each {|k,v| v.group_by{|k,v| v } }
HT
result.each {|k,v| puts v }
HT
result.each {|k,v| puts v }
HT
result.each {|k,v| v.group_by{|k,v| v } }
c
k
v
@
v.group_by { |k, v| v }
v.group_by { |k, v| v }.to_h
v
@
v.sort_by {|k,v| v}
HT
@
HT
v.sort_by {|k,v| v}.to_h
@
sorted_yo
sorted_yo = result.each { |k, v| v.sort_by { |k, v| v.sort } }
sorted_yo = result.each { |k, v| v.sort_by { |k, v| v } }
@
result.each { |k, v| v.sort_by { |k, v| v } }
@
result.transform_values { |k, v| v.sort_by { |k, v| v } }
@
v.sort_by { |k, v| v }
v.sort_by { |k, v| v }.to_h
@
v.sort_by { |k, v| v }.to_h
final
twat
@
twat.group_by { |i| i[0] }.to_h
@
twat
twat.each {|i| i.group_by {|k,v| k }}
@
HT
twat.each do |i| i.group_by {|k,v| k }
!
twat.each do |i|
!
sorted_yo = final_result.sort_by { |k, v| k }
@
sorted_yo = final_result.sort_by { |k, v| k }.to_h
quit
@
ls
processed_data
processed_data.title
processed_data[:title]
processed_data["result"]
processed_data
processed_data[:title]
processed_data
processed_data[:title]
processed_data
processed_data[:title]
@
ls
structured_data
c
Imdb.all.first
quit
Imdb.all.first
Imdb.all.find_by(primary_title: :"dirty rotten scoundrels")
quit
l
rating.to_f
rating = l[1].to_f
review = l[2].to_i
@
m = Imdd.find_by(tconst: id)
m = Imbd.find_by(tconst: id)
m = Imdb.all.find_by(tconst: id)
m
Imdb.all.first
c
m
c
m
c
m
Imdb.all.find_by(tconst: id)
id
Imdb.all.first
c
m
c
m
Imdb.all.find_by(tconst: id)
id
Imdb.all.find_by(tconst: id)
c
m
id
rating
votes
Imdb.all.find_by(primary_title: :"the silence fo the lambs")
Imdb.all.find_by(primary_title: :"the silence of the lambs")
:q
quit
HT
Imdb.all.find_by(primary_title: :"the silence of the lambs")
HR
HR 8231
Imdb.all.pluck(:average_rating)
@
HT
Imdb.all.pluck(:average_rating).where.not(average_rating: nil)
HT
Imdb.all.pluck(:average_rating).where.not(:average_rating nil)
Imdb.all.where(average_rating: nil)
Imdb.all.where.not(average_rating: nil)
quit
aa = [1,2,3,4,5]
bb = [1,2]
aa -bb
aa + bb
bb.each {|int|aa.delete(int) if aa.include?(int) }
quit
word_length
c
@
result[:results][:total_count] = result_value_count.sum
result[:results][k]
result
@
result_value_count
result[:results][:total_count]
result[:results]
c
result[:results][k]
result.each { |k, v| result[:results][k] = v.count if k.class == Integer  }
result[index]
c
result[index[
!
result[index]
result
quit
aa = "some long word group"
aa.split
aa[1]
bb = aa.split
bb[0]
quit
c
Imdb.all.find(1)
Imdb.all.find_by(title_type: :"the dark crystal")
Imdb.all.find_by(primary_title: :"the dark crystal")
quit
Imdb.first
quit
Imdb.first.tags
HT
Imdb.all.find_by(primary_title: :"the dark crystal")
aa = Imdb.all.find_by(primary_title: :"the dark crystal")
aa
aa.tags
aa.tags.create(name: :"prophecy")
aa.tags.create(name: :majic)
Imdb.all.find_by(primary_title: :"harry potter")
Imdb.all.find_by(primary_title: :"harry potter and the philosphers stone")
Imdb.all.find_by(primary_title: :"harry potter and the philosophers stone")
Imdb.all.find_by(primary_title: :"harry potter and the philosopher's stone")
Imdb.all.find_by(primary_title: :"harry potter and the prisoner of azaban")
quit
HT
Harry Potter and the Sorcerer's Stone
!
Imdb.all.find_by(primary_title: :"harry potter and the sorcerer's stone")
aa = Imdb.all.find_by(primary_title: :"harry potter and the sorcerer's stone")
aa.tags.find_or_create_by(name: majic)
aa.tags.find_or_create_by(name: :majic)
Tag.all
Tag.all.where(name: :majic)
quit
Imdb.first
HT
aa = Imdb.all.find_by(primary_title: :"harry potter and the sorcerer's stone")
aa.tags
quit
HT
aa = Imdb.all.find_by(primary_title: :"harry potter and the sorcerer's stone")
aa.tags
aa.tags.find_or_create_by(name: :majic)
Imdb.all.where(name: :majic)
@
Tag.all
Tag.first
Tag.first.imdbs
Tag.where(name: :majic)
Tag.where(name: :majic).imdbs
HT 30
HT 50
aa = Imdb.all.find_by(primary_title: :"the dark crystal")
aa
aa.tags.find_or_create_by(name: :majic)
Tag.fist
Tag.first
Tag.first.imdbs
Tag.all.where(name: :majic)
Tag.all.where(name: :majic).each {|obj| obj.imdbs }
quit
Tag.all
Tag.all.where(name: :majic)
Tag.all.where(name: :majic).imdbs
Tag.all.first.mdbs
Tag.all.first.imdbs
quit\
quit
HT
HT 30
aa = Imdb.all.find_by(primary_title: :"the dark crystal")
aa.tags.first_or_create(name: :majic)
aa = Imdb.all.find_by(primary_title: :"harry potter and the sorcerer's stone")
aa.tags.first_or_create(name: :majic)
Tag.all
Tag.find(1)
aa = Tag.find(1)
aa.imdb.first_or_create(primary_title: :"harry potter and the sorcerer's stone")
aa.imdbs.first_or_create(primary_title: :"harry potter and the sorcerer's stone")
Tag.first
Tag.first.imdbs
Tag.find_by(name: :majic)
Tag.find_by(name: :majic).first_or_create(primary_title: :"harry potter and the sorcerer's stone")
Tag.find_by(name: :majic)imdbs.first_or_create(primary_title: :"harry potter and the sorcerer's stone")
Tag.find_by(name: :majic).imdbs.first_or_create(primary_title: :"harry potter and the sorcerer's stone")
Tag.find_by(name: :majic).imdbs.
Tag.find_by(name: :majic).imdbs
!
Tag.all.find_by(name: :majic).imdbs.
Tag.all.find_by(name: :majic).imdbs
aa.imdbs.find_or_create_by(primary_title: :"harry potter and the sorcerer's stone")
aa
aa.all.imdbs
aa
aa.all.imdbs
aa.imdbs
Tag.first.imdbs
HT
Tag.first.imdbs.find_or_create_by(primary_title: :"harry potter and the sorcerer's stone")
quit
Tag.all
quit
Tag.first_or_create(name: :majic)
Tag.first_or_create(name: :trains)
Tag.first
Tag.first_or_create(name: :trains)
Tag.find_or_create_by(name: :trains)
@
HT
aa = Imdb.all.find_by(primary_title: :"harry potter and the sorcerer's stone")
aa.tags << Tag.find_by(name: :majic)
aa.tags
aa.tags << Tag.find_by(name: :trains)
Tag.where(name: :majic).imdbs
Tag.find_by(name: :majic).imdb
Tag.find_by(name: :majic).imdbs
Ht 30
HT 30
HT 50
aa = Imdb.all.find_by(primary_title: :"the dark crystal")
aa.tags << Tag.find_by(name: :majic)
Tag.find_by(name: :majic).imdbs
Tag.find_by(name: :majic).imdbs.pluck(:primary_title)
aa = Imdb.all.find_by(primary_title: :sleepers)
Tag.find_or_create_by(name: :prison)
Tag.find_or_create_by(name: :trains)
HT
HT 20
aa = Imdb.all.find_by(primary_title: :"harry potter and the sorcerer's stone").tags
aa
aa.tags << Tag.find_or_create(name: :giants)
aa
aa = Imdb.all.find_by(primary_title: :"harry potter and the sorcerer's stone")
aa.tags << Tag.find_or_create(name: :giants)
aa.tags << Tag.find_or_create_by(name: :giants)
HT
HT 20
aa = Imdb.all.find_by(primary_title: :sleepers)
aa.tags << Tag.find_or_create_by(name: :courtroom)
aa
aa.tags
aa
aa.tags << Tag.find_or_create_by(name: :prison)
aa.tags << Tag.find_or_create_by(name: :trains)
Tag.find_by(name: :tains)
Tag.find_by(name: :trains).imdbs
aa = Imdb.all.find_by(primary_name: :"primal fear")
aa = Imdb.all.find_by(primary_title: :"primal fear")
aa.tags << Tag.find_or_create_by(name: :courtroom)
HT
Tag.find_by(name: :courtroom).imdbs
aa.tags << Tag.find_or_create_by(name: :"home movies")
aa = Imdb.all.find_by(primary_name: :"red dragon")
aa = Imdb.all.find_by(primary_title: :"red dragon")
aa.tags << Tag.find_or_create_by(name: :"home movies")
 aa = Imdb.all.find_by(primary_title: :"the silence of the lambs")
aa.tags << Tag.find_or_create_by(name: :trains)
Tag.find_by(name: :trains).imdbs
HT 30
aa = Imdb.all.find_by(primary_title: :"primal fear")
aa.tags << Tag.find_by_create_by(name: :trains)
aa.tags << Tag.find_or_create_by(name: :trains)
aa.tags << Tag.find_by_create_by(name: :priests)
aa.tags << Tag.find_or_create_by(name: :priests)
aa.tags << Tag.find_or_create_by(name: :"split personality")
Tag.find_by(name: :trains)
cTag.find_by(name: :trains).imdbs
Tag.find_by(name: :trains).imdbs
HT 30
aa = Imdb.all.find_by(primary_title: :"the matrix")
aa.tags << Tag.find_or_create_by(name: :trains)
aa.tags << Tag.find_or_create_by(name: :"alice in wonderland")
HT 40
aa = Imdb.all.find_by(primary_title: :"harry potter and the sorcerer's stone")
aa.tags << Tag.find_or_create_by(name: :courtroom)
aa.tags << Tag.find_or_create_by(name: :wizard)
aa.tags << Tag.find_or_create_by(name: :witch)
aa.tags << Tag.find_or_create_by(name: :school)
aa.tags << Tag.find_or_create_by(name: :"holy grail")
aa = Imdb.find_by(primary_title: :"the da vinci code")
aa
aa.tags << Tag.find_or_create_by(name: :"holy grail")
aa.tags << Tag.find_or_create_by(name: :"leonardo da vinci")
aa.tags << Tag.find_or_create_by(name: :"jesus")
aa.tags << Tag.find_or_create_by(name: :"mary magdalene")
aa.tags << Tag.find_or_create_by(name: :"rosslyn chapel")
aa.tags << Tag.find_or_create_by(name: :"cipher")
aa.tags << Tag.find_or_create_by(name: :"cryptography")
aa.tags << Tag.find_or_create_by(name: :"church")
aa.tags << Tag.find_or_create_by(name: :"mona lisa")
aa.tags << Tag.find_or_create_by(name: :"madonna of the rocks")
aa.tags << Tag.find_or_create_by(name: :"the louvre")
aa.tags << Tag.find_or_create_by(name: :"pentagram")
Tag.find_by(name: :trains)
Tag.find_by(name: :trains).imdbs
aa = Imdb.find_by(primary_title: :"harry potter and the prisoner of azkaban")
aa.tags << Tag.find_or_create_by(name: :trains)
aa = Imdb.find_by(primary_title: :"harry potter and the goblet of fire")
aa.tags << Tag.find_or_create_by(name: :trains)
aa = Imdb.find_by(primary_title: :"harry potter and the chamber of secrets")
aa.tags << Tag.find_or_create_by(name: :trains)
aa = Imdb.find_by(primary_title: :"harry potter and the order of the phoenix")
aa.tags << Tag.find_or_create_by(name: :trains)
aa = Imdb.find_by(primary_title: :"harry potter and the deathly hallows: part 2")
aa.tags << Tag.find_or_create_by(name: :trains)
aa = Imdb.find_by(primary_title: :"harry potter and the deathly hallows: part 1")
aa.tags << Tag.find_or_create_by(name: :trains)
Tag.find_by(name: :trains)
Tag.find_by(name: :trains).imdbs
Tag.find_by(name: :trains).imdb.pluck(:primary_title)
Tag.find_by(name: :trains).imdbs.pluck(:primary_title)
aa = Imdb.find_by(name: :sleepers)
aa = Imdb.find_by(primary_title: :sleepers)
aa.tags << Tag.find_or_create_by(name: :church)
aa.tags << Tag.find_or_create_by(name: :"the count of monte christo")
aa.tags
aa.tags.last.destroy
quit
Tag.last
Tag.last.destroy
Taggin.last
Tagging.last
Tagging.last.destroy
Tag.last
Tag.last.destroy
aa.tags
aa
aa.tags
aa = Imdb.find_by(primary_title: :sleepers)
aa.tags
aa.tags << Tag.find_or_create_by(name: :"the count of monte cristo")
aa.tags << Tag.find_or_create_by(name: :"tunnel")
aa = Imdb.find_by(primary_title: :"the count of monte cristo")
aa.tags << Tag.find_or_create_by(name: :prison)
aa.tags << Tag.find_or_create_by(name: :tunnel)
aa.tags << Tag.find_or_create_by(name: :cave)
aa = Imdb.find_by(primary_title: :"indiana jones and the last crusade")
aa.tags << Tag.find_or_create_by(name: :trains)
aa.tags << Tag.find_or_create_by(name: :cave)
aa = Imdb.find_by(primary_title: :"batman begins")
aa.tags << Tag.find_or_create_by(name: :trains)
aa.tags << Tag.find_or_create_by(name: :cave)
aa.tags << Tag.find_or_create_by(name: :batman)
aa.tags << Tag.find_or_create_by(name: :"the scarecrow")
Ht 40
HT 40
Tag.find_by(name: :trains).imdbs.pluck(:primary_title)
aa = Imdb.find_by(primary_title: :"robin hood prince of thiefs")
aa = Imdb.find_by(primary_title: :"robin hood: prince of thieves")
aa.tags << Tag.find_or_create_by(name: :witch)
aa.tags << Tag.find_or_create_by(name: :blinded)
aa = Imdb.all.find_by(primary_name: :"red dragon")
aa = Imdb.all.find_by(primary_title: :"red dragon")
aa.tags << Tag.find_or_create_by(name: :blinded)
aa = Imdb.all.find_by(primary_title: :"primal fear")
aa.tags << Tag.find_or_create_by(name: :blinded)
aa = Imdb.all.find_by(primary_name: :"fight club")
aa = Imdb.all.find_by(primary_title: :"fight club")
aa.tags << Tag.find_or_create_by(name: :"split personality")
Tag.find_by(name: :blinded).imdbs
aa = Imdb.find_by(primary_title: :"stand bye me")
aa = Imdb.find_by(primary_title: :"stand by me")
aa.tags << Tag.find_or_create_by(name: :trains)
aa = Imdb.find_by(primary_title: :skyfall)
aa.tags << Tag.find_or_create_by(name: :trains)
aa.tags << Tag.find_or_create_by(name: :church)
aa.tags << Tag.find_or_create_by(name: :tunnel)
aa.tags << Tag.find_or_create_by(name: :school)
aa.tags << Tag.find_or_create_by(name: :courtroom)
Tag.find_by(name: school).imdb
Tag.find_by(name: school).imdbs
Tag.find_by(name: :school).imdbs
aa = Imdb.find_by(primary_title: :"harry potter and the chamber of secrets")
aa.tags << Tag.find_or_create_by(name: :school)
aa = Imdb.find_by(primary_title: :"harry potter and the prisoner of azkaban")
aa.tags << Tag.find_or_create_by(name: :school)
aa.tags << Tag.find_or_create_by(name: :majic)
aa = Imdb.find_by(primary_title: :"harry potter and the chamber of secrets")
aa.tags << Tag.find_or_create_by(name: :majic)
phoenix
aa = Imdb.find_by(primary_title: :"harry potter and the order of the phoenix")
aa.tags << Tag.find_or_create_by(name: :majic)
aa.tags << Tag.find_or_create_by(name: :school)
aa = Imdb.find_by(primary_title: :"harry potter and the deathly hallows: part 1")
aa.tags << Tag.find_or_create_by(name: :school)
aa.tags << Tag.find_or_create_by(name: :majic)
aa = Imdb.find_by(primary_title: :"harry potter and the deathly hallows: part 2")
aa.tags << Tag.find_or_create_by(name: :majic)
aa.tags << Tag.find_or_create_by(name: :school)
Tag.find_by(name: :majic)
Tag.find_by(name: :majic).imdbs
aa = Imdb.find_by(primary_title: :"robin hood prince of thiefs")
aa = Imdb.find_by(primary_title: :"robin hood: prince of thiefs")
aa = Imdb.find_by(primary_title: :"robin hood: prince of thieves")
aa.tags << Tag.find_or_create_by(name: :majic)
aa = Imdb.find_by(primary_title: :"harry potter and the half-blood prince")
aa.tags << Tag.find_or_create_by(name: :majic)
aa.tags << Tag.find_or_create_by(name: :trains)
aa.tags << Tag.find_or_create_by(name: :school)
Tag.find_by(name: :majic).imdbs
Tag.find_by(name: :majic).imdbs.pluck(:primary_title)
Tag.find_by(name: :blinded).imdbs
aa = Imdb.find_by(primary_title: :"robin hood prince of thiefs")
aa = Imdb.find_by(primary_title: :"robin hood: prince of thieves")
aa.tags << Tag.find_or_create_by(name: :waterfall)
aa = Imdb.find_by(primary_name: :"romance in the stone")
aa = Imdb.find_by(primary_name: :"romancing the stone")
aa = Imdb.find_by(primary_name: :"romance in the stone")
aa = Imdb.find_by(primary_title: :"romance in the stone")
aa = Imdb.find_by(primary_title: :"romancing the stone")
aa
aa.tags << Tag.find_or_create_by(name: :waterfall)
aa.tags << Tag.find_or_create_by(name: :map)
aa.tags << Tag.find_or_create_by(name: :treasure)
aa = Imdb.find_by(primary_title: :"indiana jones and the last crusade")
aa.tags << Tag.find_or_create_by(name: :treasure)
aa.tags << Tag.find_or_create_by(name: :map)
aa = Imdb.find_by(primary_title: "raiders of the lost ark")
aa = Imdb.all.find_by(primary_title: "raiders of the lost ark")
aa = Imdb.find_by(primary_title: :"raiders of the lost ark")
aa = Imdb.all.find_by(primary_title: :"raiders of the lost ark")
Tag.all
aa = Imdb.find_by(primary_title: :"the first power")
aa.tags << Tag.find_or_create_by(name: :pentagram)
aa.tags << Tag.find_or_create_by(name: :tunnel)
aa.tags << Tag.find_or_create_by(name: :church)
Tag.find_by(name: :pentagram)
Tag.find_by(name: :pentagram).imdbs
Tag.find_by(name: :cave).imdbs
aa = Imdb.find_by(primary_title: :"the fugativee")
aa = Imdb.find_by(primary_title: :"the fugative")
aa = Imdb.find_by(primary_title: :"the fugitive")
aa.tags << Tag.find_or_create_by(name: :waterfall)
aa.tags << Tag.find_or_create_by(name: :tunnel)
aa.tags << Tag.find_or_create_by(name: :"falsely accused")
aa = Imdb.find_by(priamry_title: :"the shawshank redemption")
aa = Imdb.find_by(priamry_title: :the shawshank redemption")
aa = Imdb.find_by(priamry_title: :"the shawshank redemption")
aa = Imdb.find_by(primary_title: :"the shawshank redemption")
aa.tags << Tag.find_or_create_by(name: :tunnel)
aa.tags << Tag.find_or_create_by(name: :"falsely accused")
aa.tags << Tag.find_or_create_by(name: :"prison")
aa.tags << Tag.find_or_create_by(name: :"prison guards")
aa = Imdb.find_by(primary_title: :sleepers)
aa.tags << Tag.find_or_create_by(name: :"prison guards")
aa = Imdb.find_by(primary_title: :"the fugativee")
aa = Imdb.find_by(primary_title: :"the fugative")
aa = Imdb.find_by(primary_title: :"the fugitive")
aa.tags
aa.tags << Tag.find_or_create_by(name: :"trains")
Tag.find_by(name: :trains)
Tag.find_by(name: :trains).imdbs
Tag.find_by(name: :trains).imdbs.pluck(:primary_title)
aa = Imdb.find_by(primary_title: :paycheck)
aa.tags << Tag.find_or_create_by(name: :"trains")
aa = Imdb.all.find_by(primary_title: :"primal fear")
aa.tags << Tag.find_or_create_by(name: :"plastic wrap")
aa = Imdb.find_by(primary_title: :"robin hood: prince of thieves")
aa.tags << Tag.find_or_create_by(name: :"devil worship accusation")
Tagging.last
Tagging.last.delete
Tag.last
Tag.last.delete
aa.tags
aa.last.delete
aa[4]
aa
aa.tags.last
aa.tags.last.delete
aa.tags << Tag.find_or_create_by(name: :"devil worship")
aa.tags[4]
aa.tags[4].delete
aa.tags
aa.tags[4].destroy
aa
Tag.all
aa
aa.tags
aa.tags[4]
aa.tags[4].destroy
aa.tags[4].pop
aa.tags
aa.tags.find(38)
quit
HT
HT 20
HT 30
aa = Imdb.find_by(primary_title: :"robin hood: prince of thieves")
aa
aa.tags
aa = Imdb.find_by(primary_title: :"the da vinci code")
aa.tags
aa.tags << Tag.find_or_create_by(name: :"devil worship")
Tag.last.imdbs
aa = Imdb.find_by(primary_title: :"the first power")
aa.tags << Tag.find_or_create_by(name: :"devil worship")
Tag.last.imdbs
aa = Imdb.all.find_by(primary_title: :"the matrix")
aa.tags << Tag.find_or_create_by(name: :"messiah")
Tag.find_or_create_by(name: :"prophecy")
aa.tags << Tag.find_or_create_by(name: :"prophecy")
Imdb.where("name like ?", "%harry%")
Imdb.where("primary_title like ?", "%harry%")
Imdb.where("primary_title like ?", "%harry potter%")
Imdb.find(627280)
Imdb.find(627280).destroy
Imdb.where("primary_title like ?", "%harry potter%")
HT 20
aa = Imdb.find_by(primary_title: :"")
Imdb.where("primary_title like ?", "%harry potter%").pluck(:primary_title)
aa = Imdb.find_by(primary_title: :"harry potter and the sorcerer's stone")
aa.tags << Tag.find_or_create_by(name: :prophesy)
aa.tags << Tag.find_or_create_by(name: :messiah)
aa = Imdb.find_by(primary_title: :"harry potter and the chamber of secrets")
aa.tags << Tag.find_or_create_by(name: :messiah)
v
aa.tags << Tag.find_or_create_by(name: :prophesy)
aa = Imdb.find_by(primary_title: :"harry potter and the prisoner of azkaban")
aa.tags << Tag.find_or_create_by(name: :prophesy)
aa.tags << Tag.find_or_create_by(name: :messiah)
aa = Imdb.find_by(primary_title: :"harry potter and the goblet of fire")
aa.tags << Tag.find_or_create_by(name: :messiah)
aa.tags.last.destroy
Tagging.last.destroy
Tag.last.destroy
Tag.last
quit
Ht
HT
aa = Imdb.find_by(primary_title: :"harry potter and the goblet of fire")
aa.tags
aa.tags << Tag.find_or_create_by(name: :prophecy)
Tag.all
Tagging.all
Tag.all
HT
Tag.find_or_create_by(name: :prophecy)
Tgging.all
Tagging.all
Tagging.last
Tagging.last.destroy
Tagging.find(103)
Tagging.find(103).destroy
Tagging.where(id: 41)
Tag.all
Tag.find(41)
Tag.find(41).destroy
aa
aa.tags
aa.tags.last.destroy
quit
Tag.find_by(name: :prophecy)
Tag.all
Tag.last.destroy
Tag.last
Tag.all
Tag.last.imdbs
quit
aa = Imdb.find_by(primary_title: :terminator)
aa = Imdb.find_by(primary_title: :"the terminator")
aa.tags << Tag.find_or_create_by(name: :"time travel")
aa = Imdb.find_by(primary_title: :"the terminator 2")
aa = Imdb.find_by(primary_title: :"Terminator 2: Judgment Day")
aa = Imdb.find_by(primary_title: :"terminator 2: judgment day")
aa.tags << Tag.find_or_create_by(name: :"time travel")_
aa.tags << Tag.find_or_create_by(name: :"time travel")
aa = Imdb.find_by(primary_title: :"back to the future")
aa.tags << Tag.find_or_create_by(name: :"time travel")
aa = Imdb.find_by(primary_title: :"back to the future part II")
aa = Imdb.find_by(primary_title: :"back to the future part ii")
aa.tags << Tag.find_or_create_by(name: :"time travel")
aa = Imdb.find_by(primary_title: :"back to the future part iii")
aa.tags << Tag.find_or_create_by(name: :"time travel")
Tag.find_by(name: :"time travel")
Tag.find_by(name: :"time travel").imdbs
aa = Imdb.find_by(primary_title: :terminator)
aa = Imdb.find_by(primary_title: :"the terminator")
aa.tags << Tag.find_or_create_by(name: :"robots")
aa = Imdb.find_by(primary_title: :"terminator 2: judgment day")
aa.tags << Tag.find_or_create_by(name: :"robots")
aa.tags << Tag.find_or_create_by(name: :"prophecy")
aa = Imdb.find_by(primary_title: :terminator)
aa = Imdb.find_by(primary_title: :"the terminator")
aa.tags << Tag.find_or_create_by(name: :"prophecy")
aa = Imdb.find_by(primary_title: :"back to the future part iii")
HT 40
HT 60
HT 100
Imdb.where("primary_title like ?", "%harry potter%").pluck(:primary_title)
aa = Imdb.find_by(primary_title: :"harry potter and the sorcerer's stone")
aa.tags << Tag.find_or_create_by(name: :"prophecy")
aa = Imdb.find_by(primary_title: :"harry potter and the chamber of secrets")
aa.tags << Tag.find_or_create_by(name: :"prophecy")
aa = Imdb.find_by(primary_title: :"harry potter and the prisoner of azkaban")
aa.tags << Tag.find_or_create_by(name: :"prophecy")
aa = Imdb.find_by(primary_title: :"harry potter and the goblet of fire")
aa.tags << Tag.find_or_create_by(name: :"prophecy")
aa.tags << Tag.find_or_create_by(name: :"majic")
aa.tags << Tag.find_or_create_by(name: :"school")
aa.tags << Tag.find_or_create_by(name: :"giants")
aa.tags << Tag.find_or_create_by(name: :"wizard")
aa.tags << Tag.find_or_create_by(name: :"witch")
aa.tags << Tag.find_or_create_by(name: :"holy grail")
aa.tags << Tag.find_or_create_by(name: :"courtroom")
aa = Imdb.find_by(primary_title: :"harry potter and the prisoner of azkaban")
aa.tags << Tag.find_or_create_by(name: :"courtroom")
aa.tags << Tag.find_or_create_by(name: :"wizard")
aa.tags << Tag.find_or_create_by(name: :"witch")
aa.tags << Tag.find_or_create_by(name: :"giants")
aa.tags << Tag.find_or_create_by(name: :"holy grail")
aa = Imdb.find_by(primary_title: :"harry potter and the chamber of secrets")
HT
HR 8781..8785
aa = Imdb.find_by(primary_title: :"harry potter and the sorcerer's stone")
HT
8781..8785
HR 8781..8785
aa.tags[13]
aa.tags[13].destroy
aa = Imdb.find_by(primary_title: :"harry potter and the goblet of fire")
aa.tags
quit
HT
aa = Imdb.find_by(primary_title: :"harry potter and the sorcerer's stone")
unless aa.tags
!
aa.tags
aa.tags.class
quit
Tag.all
quit
data_hash
quit
c
movie_name
movie_name = ""
c
movie_name = ""
c
movie_name = ""
c
movie_name = ""
c
quit
v 
quit
c
movie_tags
c
tag
step
movie_name
add_tag
c
Tag.all
Imdb.find_by(primary_title: :matrix)
aa = Imdb.find_by(primary_title: :matrix)
aa.tags
c
@
movie.tags.pluck(:name)
movie
Imdb.find_by(primary_title: movie_name)
movie_name
cd String
ls
quit
cd
@
movie.downcase!
movie_name.downcase!
c
args = "#{movie_name}" + "**" + "#{add_tag}"
args.downcase
args.downcase!.split("**")
c
cd Hash
ls
:quit
quit
data_hash.transform_keys!(&:downcase)
@
data_hash.transform_values!(&:downcase)
data_hash
quit
data_hash.each { |k, v| v.map(&:downcase) }
data_hash["romancing the stone"] = "This Shit"
data_hash
@
data_hash.each { |k, v| v.map(&:downcase) }
HT
data_hash["romancing the stone"] = ["This Shit", "THat shit"]
data_hash.each { |k, v| v.map(&:downcase) }
data_hash.transform_values! { |v| v.map(&:downcase) }
@
HT
data_hash["romancing the stone"] = ["This Shit", "THat shit"]
data_hash.transform_values! { |v| v.map(&:downcase) }
movie.tags
movie
movie_name
Imdb
Imdb.find_by(primary_title: movie_name)
Imdb.find_by(primary_title: :"harry potter and the philosopher's stone")
Imdb.find_by(primary_title: :"harry potter and the sorcerer's stone")
quit
movie.tags.pluck(:name)
movie
movie.tags
s
movie.tags
movie
movie.tags.present?
c
cc
c
Imdb.first
Imdb.first.tags
Imdb.first.tags.present?
movie.tags
movie.tags.pluck(:name)
movie.tags.pluck(:name).include?(generate_tag)
generate_tag
c
movie.tags.pluck(:name)
movie.tags.pluck(:name).include?("majic")
c
Imdb.find_by(primary_title: :"harry potter and the deathly hallows: Part 2")
Imdb.find_by(primary_title: :"harry potter and the deathly hallows: part 2")
quit
Imdb.find_by(primary_title: :"Raiders of the Lost Ark")
Imdb.find_by(primary_title: :"raiders of the lost ark")
quit
Tag.all
Tag.find_by(name: :train).imdbs
quit
HT
Tag.find_by(name: :train).imdbs
quit
HT
 Tag.find_by(name: :train).imdbs
quit
movie
movie.tags
@
generate_tag
movie.tags.pluck(:name).include?(generate_tag)
movie.tags.pluck(:name)
movie.tags.pluck(:name).include?(generate_tag.name)
Tag.find_by(name: :train).imdbs
quit
Imdb.find_by(primary_title: :"twin peaks")
quit
Tag.find_by(name: :giant)
Tag.find_by(name: :giant).imdbs
quit
Tag.all
quit
cd Array
ls
? Array#include?
quit
$error
$error.class
quit
$errors
aa = {a: 1}
aa.present?
aa.any?
aa = {}
aa.any?
$errors
c
Imdb.find_by(primary_title: :cracker)
Imdb
base = 16
scale = 1.250
base * scale**2
base * scale**3
base * scale**4
quit
Tag.all
quit
Imdb.first
quit
Dictionary.all.count
quit
16 * 1.25
:q
quit
base = 16
scale = 1.250
base * scale**2
base * scale**3
base * scale**4
scale**2 * base
quit
HT
HR 8966..8967
 base * scale**1
quit
Imdb
quit
imdb = Imdb.all
Imdb.all.first.update(slug: primary_title.parameterize)}
Imdb.all.first.update(slug: primary_title.parameterize)
aa = Imdb.all.first
Imdb.all.first.update(slug: aa.primary_title.parameterize)
aa
Imdb.first
my_imdb = Imdb.all
Imdb.first
quit
show-models
quit
Imdb.all.first
quit
line
quit
death
birth
known_for
l
birth
death
known_for
profession
l
Name.all.first
Name
quit
known_for
profession
death
c
Name
Imdb
Imdb.first
Imdb.first.primary_title
quit
c
Name.first
death
c
Name.first
@
Name.first
:q
quit
c
Name.first
Name.all.count
quit
Name.all.count
Name.first
:q
quit
Imdb.find_by(primary_title: "bill \u0026 ted's bogus journey")
quit
Name.all.count
quit
Name.all.count
quit
Name.all.count
quit
Name.all.count
quit
Name.all.last
quit
scale = 1.250
size = 16
scale * size**2
size * scale**2
size * scale**3
size * scale**4
quit
show-models
quit
User.first
User
quit
User.first
quit
User.all
User.first.articles
quit
User.all.first
User.all.first.articles
quit
User.all.first.articles
quit
User.all.first.articles
quit
User.first
User.first.articles
quit
User.first.articles
quit
User.first.articles
quit
User.first.articles
quit
User.first.articles
quit
User.first.destroy
Article.all
Blorgh::Article.all
Blorgh::Article.map {|a| a.destroy }
Blorgh::Article.each {|a| a.destroy }
Blorgh::Article.all.map {|a| a.destroy }
quit
User.all
quit
Comment.all
show-models
Blorgh::Comment.all
quit
@
comment_params
@article.comments
@comment = @article.comments.create(comment_params)
quit
abc = [1,5,10]
HT 50
quit
